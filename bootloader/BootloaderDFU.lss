
BootloaderDFU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000064  00800100  00007dc8  00000e9c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000dc8  00007000  00007000  000000d4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .apitable_trampolines 00000018  00007fa0  00007fa0  00000f00  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .apitable_jumptable 00000018  00007fe0  00007fe0  00000f18  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .apitable_signatures 00000008  00007ff8  00007ff8  00000f30  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .bss          0000001d  00800164  00800164  00000f38  2**0
                  ALLOC
  6 .noinit       00000002  00800181  00800181  00000f38  2**0
                  ALLOC
  7 .stab         000001f8  00000000  00000000  00000f38  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .stabstr      000000ae  00000000  00000000  00001130  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      00000011  00000000  00000000  000011de  2**0
                  CONTENTS, READONLY
 10 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000011f0  2**2
                  CONTENTS, READONLY
 11 .debug_aranges 00000248  00000000  00000000  00001230  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   000045b2  00000000  00000000  00001478  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000185a  00000000  00000000  00005a2a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000289e  00000000  00000000  00007284  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000474  00000000  00000000  00009b24  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00001b99  00000000  00000000  00009f98  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    00001e57  00000000  00000000  0000bb31  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000478  00000000  00000000  0000d988  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	39 c0       	rjmp	.+114    	; 0x7074 <__ctors_end>
    7002:	00 00       	nop
    7004:	9b c0       	rjmp	.+310    	; 0x713c <__bad_interrupt>
    7006:	00 00       	nop
    7008:	99 c0       	rjmp	.+306    	; 0x713c <__bad_interrupt>
    700a:	00 00       	nop
    700c:	97 c0       	rjmp	.+302    	; 0x713c <__bad_interrupt>
    700e:	00 00       	nop
    7010:	95 c0       	rjmp	.+298    	; 0x713c <__bad_interrupt>
    7012:	00 00       	nop
    7014:	93 c0       	rjmp	.+294    	; 0x713c <__bad_interrupt>
    7016:	00 00       	nop
    7018:	91 c0       	rjmp	.+290    	; 0x713c <__bad_interrupt>
    701a:	00 00       	nop
    701c:	8f c0       	rjmp	.+286    	; 0x713c <__bad_interrupt>
    701e:	00 00       	nop
    7020:	8d c0       	rjmp	.+282    	; 0x713c <__bad_interrupt>
    7022:	00 00       	nop
    7024:	8b c0       	rjmp	.+278    	; 0x713c <__bad_interrupt>
    7026:	00 00       	nop
    7028:	89 c0       	rjmp	.+274    	; 0x713c <__bad_interrupt>
    702a:	00 00       	nop
    702c:	5b c5       	rjmp	.+2742   	; 0x7ae4 <__vector_11>
    702e:	00 00       	nop
    7030:	85 c0       	rjmp	.+266    	; 0x713c <__bad_interrupt>
    7032:	00 00       	nop
    7034:	83 c0       	rjmp	.+262    	; 0x713c <__bad_interrupt>
    7036:	00 00       	nop
    7038:	81 c0       	rjmp	.+258    	; 0x713c <__bad_interrupt>
    703a:	00 00       	nop
    703c:	7f c0       	rjmp	.+254    	; 0x713c <__bad_interrupt>
    703e:	00 00       	nop
    7040:	7d c0       	rjmp	.+250    	; 0x713c <__bad_interrupt>
    7042:	00 00       	nop
    7044:	7b c0       	rjmp	.+246    	; 0x713c <__bad_interrupt>
    7046:	00 00       	nop
    7048:	e6 c1       	rjmp	.+972    	; 0x7416 <__vector_18>
    704a:	00 00       	nop
    704c:	77 c0       	rjmp	.+238    	; 0x713c <__bad_interrupt>
    704e:	00 00       	nop
    7050:	75 c0       	rjmp	.+234    	; 0x713c <__bad_interrupt>
    7052:	00 00       	nop
    7054:	73 c0       	rjmp	.+230    	; 0x713c <__bad_interrupt>
    7056:	00 00       	nop
    7058:	71 c0       	rjmp	.+226    	; 0x713c <__bad_interrupt>
    705a:	00 00       	nop
    705c:	6f c0       	rjmp	.+222    	; 0x713c <__bad_interrupt>
    705e:	00 00       	nop
    7060:	6d c0       	rjmp	.+218    	; 0x713c <__bad_interrupt>
    7062:	00 00       	nop
    7064:	6b c0       	rjmp	.+214    	; 0x713c <__bad_interrupt>
    7066:	00 00       	nop
    7068:	69 c0       	rjmp	.+210    	; 0x713c <__bad_interrupt>
    706a:	00 00       	nop
    706c:	67 c0       	rjmp	.+206    	; 0x713c <__bad_interrupt>
    706e:	00 00       	nop
    7070:	65 c0       	rjmp	.+202    	; 0x713c <__bad_interrupt>
    7072:	00 00       	nop

00007074 <__ctors_end>:
    7074:	11 24       	eor	r1, r1
    7076:	1f be       	out	0x3f, r1	; 63
    7078:	cf ef       	ldi	r28, 0xFF	; 255
    707a:	d4 e0       	ldi	r29, 0x04	; 4
    707c:	de bf       	out	0x3e, r29	; 62
    707e:	cd bf       	out	0x3d, r28	; 61

00007080 <Application_Jump_Check>:

		/* Re-enable JTAG debugging */
		JTAG_ENABLE();
	#else
		/* Check if the device's BOOTRST fuse is set */
		if (boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS) & FUSE_BOOTRST)
    7080:	e3 e0       	ldi	r30, 0x03	; 3
    7082:	f0 e0       	ldi	r31, 0x00	; 0
    7084:	89 e0       	ldi	r24, 0x09	; 9
    7086:	80 93 57 00 	sts	0x0057, r24
    708a:	84 91       	lpm	r24, Z
    708c:	8e 7f       	andi	r24, 0xFE	; 254
    708e:	91 f0       	breq	.+36     	; 0x70b4 <Application_Jump_Check+0x34>
		{
			/* If the reset source was not an external reset or the key is correct, clear it and jump to the application */
			if (!(MCUSR & (1 << EXTRF)) || (MagicBootKey == MAGIC_BOOT_KEY))
    7090:	04 b6       	in	r0, 0x34	; 52
    7092:	01 fe       	sbrs	r0, 1
    7094:	0a c0       	rjmp	.+20     	; 0x70aa <Application_Jump_Check+0x2a>
    7096:	81 e0       	ldi	r24, 0x01	; 1
    7098:	20 91 81 01 	lds	r18, 0x0181
    709c:	30 91 82 01 	lds	r19, 0x0182
    70a0:	22 34       	cpi	r18, 0x42	; 66
    70a2:	3c 4d       	sbci	r19, 0xDC	; 220
    70a4:	19 f0       	breq	.+6      	; 0x70ac <Application_Jump_Check+0x2c>
    70a6:	80 e0       	ldi	r24, 0x00	; 0
    70a8:	01 c0       	rjmp	.+2      	; 0x70ac <Application_Jump_Check+0x2c>
			  JumpToApplication = true;
    70aa:	81 e0       	ldi	r24, 0x01	; 1

			/* Clear reset source */
			MCUSR &= ~(1 << EXTRF);
    70ac:	94 b7       	in	r25, 0x34	; 52
    70ae:	9d 7f       	andi	r25, 0xFD	; 253
    70b0:	94 bf       	out	0x34, r25	; 52
    70b2:	11 c0       	rjmp	.+34     	; 0x70d6 <Application_Jump_Check+0x56>
		}
		else
		{
			/* If the reset source was the bootloader and the key is correct, clear it and jump to the application;
			 * this can happen in the HWBE fuse is set, and the HBE pin is low during the watchdog reset */
			if ((MCUSR & (1 << WDRF)) && (MagicBootKey == MAGIC_BOOT_KEY))
    70b4:	04 b6       	in	r0, 0x34	; 52
    70b6:	03 fe       	sbrs	r0, 3
    70b8:	0a c0       	rjmp	.+20     	; 0x70ce <Application_Jump_Check+0x4e>
    70ba:	81 e0       	ldi	r24, 0x01	; 1
    70bc:	20 91 81 01 	lds	r18, 0x0181
    70c0:	30 91 82 01 	lds	r19, 0x0182
    70c4:	22 34       	cpi	r18, 0x42	; 66
    70c6:	3c 4d       	sbci	r19, 0xDC	; 220
    70c8:	19 f0       	breq	.+6      	; 0x70d0 <Application_Jump_Check+0x50>
    70ca:	80 e0       	ldi	r24, 0x00	; 0
    70cc:	01 c0       	rjmp	.+2      	; 0x70d0 <Application_Jump_Check+0x50>
 *  start key has been loaded into \ref MagicBootKey. If the bootloader started via the watchdog and the key is valid,
 *  this will force the user application to start via a software jump.
 */
void Application_Jump_Check(void)
{
	bool JumpToApplication = false;
    70ce:	80 e0       	ldi	r24, 0x00	; 0
			 * this can happen in the HWBE fuse is set, and the HBE pin is low during the watchdog reset */
			if ((MCUSR & (1 << WDRF)) && (MagicBootKey == MAGIC_BOOT_KEY))
				JumpToApplication = true;

			/* Clear reset source */
			MCUSR &= ~(1 << WDRF);
    70d0:	94 b7       	in	r25, 0x34	; 52
    70d2:	97 7f       	andi	r25, 0xF7	; 247
    70d4:	94 bf       	out	0x34, r25	; 52
		}
	#endif

	/* Don't run the user application if the reset vector is blank (no app loaded) */
	bool ApplicationValid = (pgm_read_word_near(0) != 0xFFFF);
    70d6:	20 e0       	ldi	r18, 0x00	; 0
    70d8:	30 e0       	ldi	r19, 0x00	; 0
    70da:	f9 01       	movw	r30, r18
    70dc:	45 91       	lpm	r20, Z+
    70de:	54 91       	lpm	r21, Z

	/* If a request has been made to jump to the user application, honor it */
	if (JumpToApplication && ApplicationValid)
    70e0:	88 23       	and	r24, r24
    70e2:	b9 f0       	breq	.+46     	; 0x7112 <__do_copy_data>
    70e4:	4f 3f       	cpi	r20, 0xFF	; 255
    70e6:	5f 4f       	sbci	r21, 0xFF	; 255
    70e8:	a1 f0       	breq	.+40     	; 0x7112 <__do_copy_data>
	{
		/* Turn off the watchdog */
		MCUSR &= ~(1 << WDRF);
    70ea:	84 b7       	in	r24, 0x34	; 52
    70ec:	87 7f       	andi	r24, 0xF7	; 247
    70ee:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    70f0:	0f b6       	in	r0, 0x3f	; 63
    70f2:	f8 94       	cli
    70f4:	a8 95       	wdr
    70f6:	80 91 60 00 	lds	r24, 0x0060
    70fa:	88 61       	ori	r24, 0x18	; 24
    70fc:	80 93 60 00 	sts	0x0060, r24
    7100:	10 92 60 00 	sts	0x0060, r1
    7104:	0f be       	out	0x3f, r0	; 63
		wdt_disable();

		/* Clear the boot key and jump to the user application */
		MagicBootKey = 0;
    7106:	10 92 82 01 	sts	0x0182, r1
    710a:	10 92 81 01 	sts	0x0181, r1

		// cppcheck-suppress constStatement
		((void (*)(void))0x0000)();
    710e:	f9 01       	movw	r30, r18
    7110:	09 95       	icall

00007112 <__do_copy_data>:
    7112:	11 e0       	ldi	r17, 0x01	; 1
    7114:	a0 e0       	ldi	r26, 0x00	; 0
    7116:	b1 e0       	ldi	r27, 0x01	; 1
    7118:	e8 ec       	ldi	r30, 0xC8	; 200
    711a:	fd e7       	ldi	r31, 0x7D	; 125
    711c:	02 c0       	rjmp	.+4      	; 0x7122 <__do_copy_data+0x10>
    711e:	05 90       	lpm	r0, Z+
    7120:	0d 92       	st	X+, r0
    7122:	a4 36       	cpi	r26, 0x64	; 100
    7124:	b1 07       	cpc	r27, r17
    7126:	d9 f7       	brne	.-10     	; 0x711e <__do_copy_data+0xc>

00007128 <__do_clear_bss>:
    7128:	21 e0       	ldi	r18, 0x01	; 1
    712a:	a4 e6       	ldi	r26, 0x64	; 100
    712c:	b1 e0       	ldi	r27, 0x01	; 1
    712e:	01 c0       	rjmp	.+2      	; 0x7132 <.do_clear_bss_start>

00007130 <.do_clear_bss_loop>:
    7130:	1d 92       	st	X+, r1

00007132 <.do_clear_bss_start>:
    7132:	a1 38       	cpi	r26, 0x81	; 129
    7134:	b2 07       	cpc	r27, r18
    7136:	e1 f7       	brne	.-8      	; 0x7130 <.do_clear_bss_loop>
    7138:	35 d1       	rcall	.+618    	; 0x73a4 <main>
    713a:	44 c6       	rjmp	.+3208   	; 0x7dc4 <_exit>

0000713c <__bad_interrupt>:
    713c:	61 cf       	rjmp	.-318    	; 0x7000 <__vectors>

0000713e <DiscardFillerBytes>:
 *
 *  \param[in] NumberOfBytes  Number of bytes to discard from the host from the control endpoint
 */
static void DiscardFillerBytes(uint8_t NumberOfBytes)
{
	while (NumberOfBytes--)
    713e:	88 23       	and	r24, r24
    7140:	91 f0       	breq	.+36     	; 0x7166 <DiscardFillerBytes+0x28>
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    7142:	90 91 f2 00 	lds	r25, 0x00F2
	{
		if (!(Endpoint_BytesInEndpoint()))
    7146:	91 11       	cpse	r25, r1
    7148:	0f c0       	rjmp	.+30     	; 0x7168 <DiscardFillerBytes+0x2a>
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);
    714a:	90 91 e8 00 	lds	r25, 0x00E8
    714e:	9b 7f       	andi	r25, 0xFB	; 251
    7150:	90 93 e8 00 	sts	0x00E8, r25
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7154:	90 91 e8 00 	lds	r25, 0x00E8
		{
			Endpoint_ClearOUT();

			/* Wait until next data packet received */
			while (!(Endpoint_IsOUTReceived()))
    7158:	92 ff       	sbrs	r25, 2
    715a:	02 c0       	rjmp	.+4      	; 0x7160 <DiscardFillerBytes+0x22>
 *
 *  \param[in] NumberOfBytes  Number of bytes to discard from the host from the control endpoint
 */
static void DiscardFillerBytes(uint8_t NumberOfBytes)
{
	while (NumberOfBytes--)
    715c:	81 50       	subi	r24, 0x01	; 1
    715e:	ef cf       	rjmp	.-34     	; 0x713e <DiscardFillerBytes>
			Endpoint_ClearOUT();

			/* Wait until next data packet received */
			while (!(Endpoint_IsOUTReceived()))
			{
				if (USB_DeviceState == DEVICE_STATE_Unattached)
    7160:	9e b3       	in	r25, 0x1e	; 30
    7162:	91 11       	cpse	r25, r1
    7164:	f7 cf       	rjmp	.-18     	; 0x7154 <DiscardFillerBytes+0x16>
    7166:	08 95       	ret
			static inline void Endpoint_Discard_8(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Discard_8(void)
			{
				uint8_t Dummy;

				Dummy = UEDATX;
    7168:	90 91 f1 00 	lds	r25, 0x00F1
    716c:	f7 cf       	rjmp	.-18     	; 0x715c <DiscardFillerBytes+0x1e>

0000716e <LoadStartEndAddresses>:
{
	union
	{
		uint8_t  Bytes[2];
		uint16_t Word;
	} Address[2] = {{.Bytes = {SentCommand.Data[2], SentCommand.Data[1]}},
    716e:	ec e6       	ldi	r30, 0x6C	; 108
    7170:	f1 e0       	ldi	r31, 0x01	; 1
    7172:	35 81       	ldd	r19, Z+5	; 0x05
    7174:	24 81       	ldd	r18, Z+4	; 0x04
	                {.Bytes = {SentCommand.Data[4], SentCommand.Data[3]}}};

	/* Load in the start and ending read addresses from the sent data packet */
	StartAddr = Address[0].Word;
    7176:	93 81       	ldd	r25, Z+3	; 0x03
    7178:	82 81       	ldd	r24, Z+2	; 0x02
    717a:	90 93 66 01 	sts	0x0166, r25
    717e:	80 93 67 01 	sts	0x0167, r24
	EndAddr   = Address[1].Word;
    7182:	c9 01       	movw	r24, r18
    7184:	90 93 64 01 	sts	0x0164, r25
    7188:	80 93 65 01 	sts	0x0165, r24
    718c:	08 95       	ret

0000718e <ProcessBootloaderCommand>:
/** Routine to process an issued command from the host, via a DFU_DNLOAD request wrapper. This routine ensures
 *  that the command is allowed based on the current secure mode flag value, and passes the command off to the
 *  appropriate handler function.
 */
static void ProcessBootloaderCommand(void)
{
    718e:	1f 93       	push	r17
    7190:	cf 93       	push	r28
    7192:	df 93       	push	r29
    7194:	00 d0       	rcall	.+0      	; 0x7196 <ProcessBootloaderCommand+0x8>
    7196:	1f 92       	push	r1
    7198:	cd b7       	in	r28, 0x3d	; 61
    719a:	de b7       	in	r29, 0x3e	; 62
	/* Check if device is in secure mode */
	if (IsSecure)
    719c:	90 91 76 01 	lds	r25, 0x0176
    71a0:	80 91 6c 01 	lds	r24, 0x016C
    71a4:	99 23       	and	r25, r25
    71a6:	d9 f1       	breq	.+118    	; 0x721e <ProcessBootloaderCommand+0x90>
	{
		/* Don't process command unless it is a READ or chip erase command */
		if (!(((SentCommand.Command == COMMAND_WRITE)             &&
    71a8:	84 30       	cpi	r24, 0x04	; 4
    71aa:	21 f5       	brne	.+72     	; 0x71f4 <ProcessBootloaderCommand+0x66>
    71ac:	80 91 6d 01 	lds	r24, 0x016D
    71b0:	81 11       	cpse	r24, r1
    71b2:	23 c0       	rjmp	.+70     	; 0x71fa <ProcessBootloaderCommand+0x6c>
		        IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF)) ||
    71b4:	80 91 6e 01 	lds	r24, 0x016E
    71b8:	8f 3f       	cpi	r24, 0xFF	; 255
    71ba:	f9 f4       	brne	.+62     	; 0x71fa <ProcessBootloaderCommand+0x6c>
/** Handler for a Data Write command issued by the host. This routine handles non-programming commands such as
 *  bootloader exit (both via software jumps and hardware watchdog resets) and flash memory erasure.
 */
static void ProcessWriteCommand(void)
{
	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x03))                            // Start application
    71bc:	80 91 6d 01 	lds	r24, 0x016D
    71c0:	83 30       	cpi	r24, 0x03	; 3
    71c2:	09 f0       	breq	.+2      	; 0x71c6 <ProcessBootloaderCommand+0x38>
    71c4:	9a c0       	rjmp	.+308    	; 0x72fa <ProcessBootloaderCommand+0x16c>
	{
		/* Indicate that the bootloader is terminating */
		WaitForExit = true;
    71c6:	81 e0       	ldi	r24, 0x01	; 1
    71c8:	80 93 75 01 	sts	0x0175, r24

		/* Check if data supplied for the Start Program command - no data executes the program */
		if (SentCommand.DataSize)
    71cc:	e0 91 72 01 	lds	r30, 0x0172
    71d0:	f0 91 73 01 	lds	r31, 0x0173
    71d4:	80 91 6e 01 	lds	r24, 0x016E
    71d8:	30 97       	sbiw	r30, 0x00	; 0
    71da:	09 f4       	brne	.+2      	; 0x71de <ProcessBootloaderCommand+0x50>
    71dc:	73 c0       	rjmp	.+230    	; 0x72c4 <ProcessBootloaderCommand+0x136>
		{
			if (SentCommand.Data[1] == 0x01)                                   // Start via jump
    71de:	81 30       	cpi	r24, 0x01	; 1
    71e0:	b9 f4       	brne	.+46     	; 0x7210 <ProcessBootloaderCommand+0x82>
			{
				union
				{
					uint8_t  Bytes[2];
					AppPtr_t FuncPtr;
				} Address = {.Bytes = {SentCommand.Data[4], SentCommand.Data[3]}};
    71e2:	90 91 71 01 	lds	r25, 0x0171
    71e6:	80 91 70 01 	lds	r24, 0x0170

				/* Load in the jump address into the application start address pointer */
				AppStartPtr = Address.FuncPtr;
    71ea:	90 93 69 01 	sts	0x0169, r25
    71ee:	80 93 6a 01 	sts	0x016A, r24
    71f2:	0e c0       	rjmp	.+28     	; 0x7210 <ProcessBootloaderCommand+0x82>
{
	/* Check if device is in secure mode */
	if (IsSecure)
	{
		/* Don't process command unless it is a READ or chip erase command */
		if (!(((SentCommand.Command == COMMAND_WRITE)             &&
    71f4:	85 30       	cpi	r24, 0x05	; 5
    71f6:	09 f4       	brne	.+2      	; 0x71fa <ProcessBootloaderCommand+0x6c>
    71f8:	a4 c0       	rjmp	.+328    	; 0x7342 <ProcessBootloaderCommand+0x1b4>
		        IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF)) ||
			   (SentCommand.Command == COMMAND_READ)))
		{
			/* Set the state and status variables to indicate the error */
			DFU_State  = dfuERROR;
    71fa:	8a e0       	ldi	r24, 0x0A	; 10
    71fc:	80 93 00 01 	sts	0x0100, r24
			DFU_Status = errWRITE;
    7200:	83 e0       	ldi	r24, 0x03	; 3
    7202:	80 93 74 01 	sts	0x0174, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    7206:	80 91 eb 00 	lds	r24, 0x00EB
    720a:	80 62       	ori	r24, 0x20	; 32
    720c:	80 93 eb 00 	sts	0x00EB, r24
			if (IS_TWOBYTE_COMMAND(SentCommand.Data, 0x03, 0x00))              // Set 64KB flash page command
			  Flash64KBPage = SentCommand.Data[2];

			break;
	}
}
    7210:	0f 90       	pop	r0
    7212:	0f 90       	pop	r0
    7214:	0f 90       	pop	r0
    7216:	df 91       	pop	r29
    7218:	cf 91       	pop	r28
    721a:	1f 91       	pop	r17
    721c:	08 95       	ret
			return;
		}
	}

	/* Dispatch the required command processing routine based on the command type */
	switch (SentCommand.Command)
    721e:	84 30       	cpi	r24, 0x04	; 4
    7220:	69 f2       	breq	.-102    	; 0x71bc <ProcessBootloaderCommand+0x2e>
    7222:	60 f4       	brcc	.+24     	; 0x723c <ProcessBootloaderCommand+0xae>
    7224:	81 30       	cpi	r24, 0x01	; 1
    7226:	e1 f0       	breq	.+56     	; 0x7260 <ProcessBootloaderCommand+0xd2>
    7228:	83 30       	cpi	r24, 0x03	; 3
    722a:	91 f7       	brne	.-28     	; 0x7210 <ProcessBootloaderCommand+0x82>
 *  to read subsequent data from the specified memory out to the host, as well as implementing the memory
 *  blank check command.
 */
static void ProcessMemReadCommand(void)
{
	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00) ||                          // Read FLASH command
    722c:	80 91 6d 01 	lds	r24, 0x016D
    7230:	98 2f       	mov	r25, r24
    7232:	9d 7f       	andi	r25, 0xFD	; 253
    7234:	61 f5       	brne	.+88     	; 0x728e <ProcessBootloaderCommand+0x100>
        IS_ONEBYTE_COMMAND(SentCommand.Data, 0x02))                            // Read EEPROM command
	{
		/* Load in the start and ending read addresses */
		LoadStartEndAddresses();
    7236:	9b df       	rcall	.-202    	; 0x716e <LoadStartEndAddresses>

		/* Set the state so that the next UPLOAD requests read out the firmware */
		DFU_State = dfuUPLOAD_IDLE;
    7238:	89 e0       	ldi	r24, 0x09	; 9
    723a:	26 c0       	rjmp	.+76     	; 0x7288 <ProcessBootloaderCommand+0xfa>
			return;
		}
	}

	/* Dispatch the required command processing routine based on the command type */
	switch (SentCommand.Command)
    723c:	85 30       	cpi	r24, 0x05	; 5
    723e:	09 f4       	brne	.+2      	; 0x7242 <ProcessBootloaderCommand+0xb4>
    7240:	80 c0       	rjmp	.+256    	; 0x7342 <ProcessBootloaderCommand+0x1b4>
    7242:	86 30       	cpi	r24, 0x06	; 6
    7244:	29 f7       	brne	.-54     	; 0x7210 <ProcessBootloaderCommand+0x82>
			break;
		case COMMAND_READ:
			ProcessReadCommand();
			break;
		case COMMAND_CHANGE_BASE_ADDR:
			if (IS_TWOBYTE_COMMAND(SentCommand.Data, 0x03, 0x00))              // Set 64KB flash page command
    7246:	80 91 6d 01 	lds	r24, 0x016D
    724a:	83 30       	cpi	r24, 0x03	; 3
    724c:	09 f7       	brne	.-62     	; 0x7210 <ProcessBootloaderCommand+0x82>
    724e:	80 91 6e 01 	lds	r24, 0x016E
    7252:	81 11       	cpse	r24, r1
    7254:	dd cf       	rjmp	.-70     	; 0x7210 <ProcessBootloaderCommand+0x82>
			  Flash64KBPage = SentCommand.Data[2];
    7256:	80 91 6f 01 	lds	r24, 0x016F
    725a:	80 93 68 01 	sts	0x0168, r24
    725e:	d8 cf       	rjmp	.-80     	; 0x7210 <ProcessBootloaderCommand+0x82>
/** Handler for a Memory Program command issued by the host. This routine handles the preparations needed
 *  to write subsequent data from the host into the specified memory.
 */
static void ProcessMemProgCommand(void)
{
	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00) ||                          // Write FLASH command
    7260:	10 91 6d 01 	lds	r17, 0x016D
    7264:	12 30       	cpi	r17, 0x02	; 2
    7266:	a0 f6       	brcc	.-88     	; 0x7210 <ProcessBootloaderCommand+0x82>
	    IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                            // Write EEPROM command
	{
		/* Load in the start and ending read addresses */
		LoadStartEndAddresses();
    7268:	82 df       	rcall	.-252    	; 0x716e <LoadStartEndAddresses>

		/* If FLASH is being written to, we need to pre-erase the first page to write to */
		if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))
    726a:	11 11       	cpse	r17, r1
    726c:	0c c0       	rjmp	.+24     	; 0x7286 <ProcessBootloaderCommand+0xf8>
		{
			union
			{
				uint16_t Words[2];
				uint32_t Long;
			} CurrFlashAddress = {.Words = {StartAddr, Flash64KBPage}};
    726e:	80 91 66 01 	lds	r24, 0x0166
    7272:	90 91 67 01 	lds	r25, 0x0167

			/* Erase the current page's temp buffer */
			boot_page_erase(CurrFlashAddress.Long);
    7276:	23 e0       	ldi	r18, 0x03	; 3
    7278:	fc 01       	movw	r30, r24
    727a:	20 93 57 00 	sts	0x0057, r18
    727e:	e8 95       	spm
			boot_spm_busy_wait();
    7280:	07 b6       	in	r0, 0x37	; 55
    7282:	00 fc       	sbrc	r0, 0
    7284:	fd cf       	rjmp	.-6      	; 0x7280 <ProcessBootloaderCommand+0xf2>
		}

		/* Set the state so that the next DNLOAD requests reads in the firmware */
		DFU_State = dfuDNLOAD_IDLE;
    7286:	85 e0       	ldi	r24, 0x05	; 5
	{
		/* Load in the start and ending read addresses */
		LoadStartEndAddresses();

		/* Set the state so that the next UPLOAD requests read out the firmware */
		DFU_State = dfuUPLOAD_IDLE;
    7288:	80 93 00 01 	sts	0x0100, r24
    728c:	c1 cf       	rjmp	.-126    	; 0x7210 <ProcessBootloaderCommand+0x82>
	}
	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                       // Blank check FLASH command
    728e:	81 30       	cpi	r24, 0x01	; 1
    7290:	09 f0       	breq	.+2      	; 0x7294 <ProcessBootloaderCommand+0x106>
    7292:	be cf       	rjmp	.-132    	; 0x7210 <ProcessBootloaderCommand+0x82>
    7294:	e0 e0       	ldi	r30, 0x00	; 0
    7296:	f0 e0       	ldi	r31, 0x00	; 0
		{
			/* Check if the current byte is not blank */
			#if (FLASHEND > 0xFFFF)
			if (pgm_read_byte_far(CurrFlashAddress) != 0xFF)
			#else
			if (pgm_read_byte(CurrFlashAddress) != 0xFF)
    7298:	84 91       	lpm	r24, Z
    729a:	8f 3f       	cpi	r24, 0xFF	; 255
    729c:	69 f0       	breq	.+26     	; 0x72b8 <ProcessBootloaderCommand+0x12a>
			#endif
			{
				/* Save the location of the first non-blank byte for response back to the host */
				Flash64KBPage = (CurrFlashAddress >> 16);
    729e:	10 92 68 01 	sts	0x0168, r1
				StartAddr     = CurrFlashAddress;
    72a2:	f0 93 67 01 	sts	0x0167, r31
    72a6:	e0 93 66 01 	sts	0x0166, r30

				/* Set state and status variables to the appropriate error values */
				DFU_State  = dfuERROR;
    72aa:	8a e0       	ldi	r24, 0x0A	; 10
    72ac:	80 93 00 01 	sts	0x0100, r24
				DFU_Status = errCHECK_ERASED;
    72b0:	85 e0       	ldi	r24, 0x05	; 5

	if (ReadAddressInvalid)
	{
		/* Set the state and status variables to indicate the error */
		DFU_State  = dfuERROR;
		DFU_Status = errADDRESS;
    72b2:	80 93 74 01 	sts	0x0174, r24
    72b6:	ac cf       	rjmp	.-168    	; 0x7210 <ProcessBootloaderCommand+0x82>
    72b8:	31 96       	adiw	r30, 0x01	; 1
	}
	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                       // Blank check FLASH command
	{
		uint32_t CurrFlashAddress = 0;

		while (CurrFlashAddress < (uint32_t)BOOT_START_ADDR)
    72ba:	e1 15       	cp	r30, r1
    72bc:	20 e7       	ldi	r18, 0x70	; 112
    72be:	f2 07       	cpc	r31, r18
    72c0:	59 f7       	brne	.-42     	; 0x7298 <ProcessBootloaderCommand+0x10a>
    72c2:	a6 cf       	rjmp	.-180    	; 0x7210 <ProcessBootloaderCommand+0x82>
				AppStartPtr = Address.FuncPtr;
			}
		}
		else
		{
			if (SentCommand.Data[1] == 0x00)                                   // Start via watchdog
    72c4:	81 11       	cpse	r24, r1
    72c6:	11 c0       	rjmp	.+34     	; 0x72ea <ProcessBootloaderCommand+0x15c>
			{
				/* Unlock the forced application start mode of the bootloader if it is restarted */
				MagicBootKey = MAGIC_BOOT_KEY;
    72c8:	82 e4       	ldi	r24, 0x42	; 66
    72ca:	9c ed       	ldi	r25, 0xDC	; 220
    72cc:	90 93 82 01 	sts	0x0182, r25
    72d0:	80 93 81 01 	sts	0x0181, r24
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    72d4:	9c e0       	ldi	r25, 0x0C	; 12
    72d6:	88 e1       	ldi	r24, 0x18	; 24
    72d8:	0f b6       	in	r0, 0x3f	; 63
    72da:	f8 94       	cli
    72dc:	a8 95       	wdr
    72de:	80 93 60 00 	sts	0x0060, r24
    72e2:	0f be       	out	0x3f, r0	; 63
    72e4:	90 93 60 00 	sts	0x0060, r25
    72e8:	93 cf       	rjmp	.-218    	; 0x7210 <ProcessBootloaderCommand+0x82>
				wdt_enable(WDTO_250MS);
			}
			else                                                               // Start via jump
			{
				/* Set the flag to terminate the bootloader at next opportunity if a valid application has been loaded */
				if (pgm_read_word_near(0) == 0xFFFF)
    72ea:	85 91       	lpm	r24, Z+
    72ec:	94 91       	lpm	r25, Z
    72ee:	01 96       	adiw	r24, 0x01	; 1
    72f0:	09 f0       	breq	.+2      	; 0x72f4 <ProcessBootloaderCommand+0x166>
    72f2:	8e cf       	rjmp	.-228    	; 0x7210 <ProcessBootloaderCommand+0x82>
				  RunBootloader = false;
    72f4:	10 92 01 01 	sts	0x0101, r1
    72f8:	8b cf       	rjmp	.-234    	; 0x7210 <ProcessBootloaderCommand+0x82>
			}
		}
	}
	else if (IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF))                 // Erase flash
    72fa:	81 11       	cpse	r24, r1
    72fc:	89 cf       	rjmp	.-238    	; 0x7210 <ProcessBootloaderCommand+0x82>
    72fe:	80 91 6e 01 	lds	r24, 0x016E
    7302:	8f 3f       	cpi	r24, 0xFF	; 255
    7304:	09 f0       	breq	.+2      	; 0x7308 <ProcessBootloaderCommand+0x17a>
    7306:	84 cf       	rjmp	.-248    	; 0x7210 <ProcessBootloaderCommand+0x82>
    7308:	e0 e0       	ldi	r30, 0x00	; 0
    730a:	f0 e0       	ldi	r31, 0x00	; 0
		uint32_t CurrFlashAddress = 0;

		/* Clear the application section of flash */
		while (CurrFlashAddress < (uint32_t)BOOT_START_ADDR)
		{
			boot_page_erase(CurrFlashAddress);
    730c:	83 e0       	ldi	r24, 0x03	; 3
			boot_spm_busy_wait();
			boot_page_write(CurrFlashAddress);
    730e:	95 e0       	ldi	r25, 0x05	; 5
		uint32_t CurrFlashAddress = 0;

		/* Clear the application section of flash */
		while (CurrFlashAddress < (uint32_t)BOOT_START_ADDR)
		{
			boot_page_erase(CurrFlashAddress);
    7310:	80 93 57 00 	sts	0x0057, r24
    7314:	e8 95       	spm
			boot_spm_busy_wait();
    7316:	07 b6       	in	r0, 0x37	; 55
    7318:	00 fc       	sbrc	r0, 0
    731a:	fd cf       	rjmp	.-6      	; 0x7316 <ProcessBootloaderCommand+0x188>
			boot_page_write(CurrFlashAddress);
    731c:	90 93 57 00 	sts	0x0057, r25
    7320:	e8 95       	spm
			boot_spm_busy_wait();
    7322:	07 b6       	in	r0, 0x37	; 55
    7324:	00 fc       	sbrc	r0, 0
    7326:	fd cf       	rjmp	.-6      	; 0x7322 <ProcessBootloaderCommand+0x194>
    7328:	e0 58       	subi	r30, 0x80	; 128
    732a:	ff 4f       	sbci	r31, 0xFF	; 255
	else if (IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF))                 // Erase flash
	{
		uint32_t CurrFlashAddress = 0;

		/* Clear the application section of flash */
		while (CurrFlashAddress < (uint32_t)BOOT_START_ADDR)
    732c:	e1 15       	cp	r30, r1
    732e:	20 e7       	ldi	r18, 0x70	; 112
    7330:	f2 07       	cpc	r31, r18
    7332:	71 f7       	brne	.-36     	; 0x7310 <ProcessBootloaderCommand+0x182>

			CurrFlashAddress += SPM_PAGESIZE;
		}

		/* Re-enable the RWW section of flash as writing to the flash locks it out */
		boot_rww_enable();
    7334:	81 e1       	ldi	r24, 0x11	; 17
    7336:	80 93 57 00 	sts	0x0057, r24
    733a:	e8 95       	spm

		/* Memory has been erased, reset the security bit so that programming/reading is allowed */
		IsSecure = false;
    733c:	10 92 76 01 	sts	0x0176, r1
    7340:	67 cf       	rjmp	.-306    	; 0x7210 <ProcessBootloaderCommand+0x82>
/** Handler for a Data Read command issued by the host. This routine handles bootloader information retrieval
 *  commands such as device signature and bootloader version retrieval.
 */
static void ProcessReadCommand(void)
{
	const uint8_t BootloaderInfo[3] = {BOOTLOADER_VERSION, BOOTLOADER_ID_BYTE1, BOOTLOADER_ID_BYTE2};
    7342:	80 91 02 01 	lds	r24, 0x0102
    7346:	90 91 03 01 	lds	r25, 0x0103
    734a:	a0 91 04 01 	lds	r26, 0x0104
    734e:	89 83       	std	Y+1, r24	; 0x01
    7350:	9a 83       	std	Y+2, r25	; 0x02
    7352:	ab 83       	std	Y+3, r26	; 0x03
	const uint8_t SignatureInfo[4]  = {0x58, AVR_SIGNATURE_1, AVR_SIGNATURE_2, AVR_SIGNATURE_3};

	uint8_t DataIndexToRead    = SentCommand.Data[1];
    7354:	80 91 6e 01 	lds	r24, 0x016E
	bool    ReadAddressInvalid = false;

	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))                        // Read bootloader info
    7358:	90 91 6d 01 	lds	r25, 0x016D
    735c:	91 11       	cpse	r25, r1
    735e:	09 c0       	rjmp	.+18     	; 0x7372 <ProcessBootloaderCommand+0x1e4>
	{
		if (DataIndexToRead < 3)
    7360:	83 30       	cpi	r24, 0x03	; 3
    7362:	78 f4       	brcc	.+30     	; 0x7382 <ProcessBootloaderCommand+0x1f4>
		  ResponseByte = BootloaderInfo[DataIndexToRead];
    7364:	fe 01       	movw	r30, r28
    7366:	e8 0f       	add	r30, r24
    7368:	f1 1d       	adc	r31, r1
    736a:	81 81       	ldd	r24, Z+1	; 0x01
				break;
			case 0x60:
				ResponseByte = SignatureInfo[2];
				break;
			case 0x61:
				ResponseByte = SignatureInfo[3];
    736c:	80 93 6b 01 	sts	0x016B, r24
    7370:	4f cf       	rjmp	.-354    	; 0x7210 <ProcessBootloaderCommand+0x82>
		if (DataIndexToRead < 3)
		  ResponseByte = BootloaderInfo[DataIndexToRead];
		else
		  ReadAddressInvalid = true;
	}
	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                    // Read signature byte
    7372:	91 30       	cpi	r25, 0x01	; 1
    7374:	09 f0       	breq	.+2      	; 0x7378 <ProcessBootloaderCommand+0x1ea>
    7376:	4c cf       	rjmp	.-360    	; 0x7210 <ProcessBootloaderCommand+0x82>
	{
		switch (DataIndexToRead)
    7378:	81 33       	cpi	r24, 0x31	; 49
    737a:	81 f0       	breq	.+32     	; 0x739c <ProcessBootloaderCommand+0x20e>
    737c:	38 f4       	brcc	.+14     	; 0x738c <ProcessBootloaderCommand+0x1fe>
    737e:	80 33       	cpi	r24, 0x30	; 48
    7380:	59 f0       	breq	.+22     	; 0x7398 <ProcessBootloaderCommand+0x20a>
	}

	if (ReadAddressInvalid)
	{
		/* Set the state and status variables to indicate the error */
		DFU_State  = dfuERROR;
    7382:	8a e0       	ldi	r24, 0x0A	; 10
    7384:	80 93 00 01 	sts	0x0100, r24
		DFU_Status = errADDRESS;
    7388:	88 e0       	ldi	r24, 0x08	; 8
    738a:	93 cf       	rjmp	.-218    	; 0x72b2 <ProcessBootloaderCommand+0x124>
		else
		  ReadAddressInvalid = true;
	}
	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                    // Read signature byte
	{
		switch (DataIndexToRead)
    738c:	80 36       	cpi	r24, 0x60	; 96
    738e:	41 f0       	breq	.+16     	; 0x73a0 <ProcessBootloaderCommand+0x212>
    7390:	81 36       	cpi	r24, 0x61	; 97
    7392:	b9 f7       	brne	.-18     	; 0x7382 <ProcessBootloaderCommand+0x1f4>
				break;
			case 0x60:
				ResponseByte = SignatureInfo[2];
				break;
			case 0x61:
				ResponseByte = SignatureInfo[3];
    7394:	8a e8       	ldi	r24, 0x8A	; 138
    7396:	ea cf       	rjmp	.-44     	; 0x736c <ProcessBootloaderCommand+0x1de>
	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                    // Read signature byte
	{
		switch (DataIndexToRead)
		{
			case 0x30:
				ResponseByte = SignatureInfo[0];
    7398:	88 e5       	ldi	r24, 0x58	; 88
    739a:	e8 cf       	rjmp	.-48     	; 0x736c <ProcessBootloaderCommand+0x1de>
				break;
			case 0x31:
				ResponseByte = SignatureInfo[1];
    739c:	8e e1       	ldi	r24, 0x1E	; 30
    739e:	e6 cf       	rjmp	.-52     	; 0x736c <ProcessBootloaderCommand+0x1de>
				break;
			case 0x60:
				ResponseByte = SignatureInfo[2];
    73a0:	85 e9       	ldi	r24, 0x95	; 149
    73a2:	e4 cf       	rjmp	.-56     	; 0x736c <ProcessBootloaderCommand+0x1de>

000073a4 <main>:

/** Configures all hardware required for the bootloader. */
static void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
    73a4:	84 b7       	in	r24, 0x34	; 52
    73a6:	87 7f       	andi	r24, 0xF7	; 247
    73a8:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    73aa:	0f b6       	in	r0, 0x3f	; 63
    73ac:	f8 94       	cli
    73ae:	a8 95       	wdr
    73b0:	80 91 60 00 	lds	r24, 0x0060
    73b4:	88 61       	ori	r24, 0x18	; 24
    73b6:	80 93 60 00 	sts	0x0060, r24
    73ba:	10 92 60 00 	sts	0x0060, r1
    73be:	0f be       	out	0x3f, r0	; 63
from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
    73c0:	90 e0       	ldi	r25, 0x00	; 0
    73c2:	80 e8       	ldi	r24, 0x80	; 128
    73c4:	0f b6       	in	r0, 0x3f	; 63
    73c6:	f8 94       	cli
    73c8:	80 93 61 00 	sts	0x0061, r24
    73cc:	90 93 61 00 	sts	0x0061, r25
    73d0:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);

	/* Relocate the interrupt vector table to the bootloader section */
	MCUCR = (1 << IVCE);
    73d2:	c1 e0       	ldi	r28, 0x01	; 1
    73d4:	c5 bf       	out	0x35, r28	; 53
	MCUCR = (1 << IVSEL);
    73d6:	82 e0       	ldi	r24, 0x02	; 2
    73d8:	85 bf       	out	0x35, r24	; 53

	/* Initialize the USB and other board hardware drivers */
	USB_Init();
    73da:	75 d3       	rcall	.+1770   	; 0x7ac6 <USB_Init>
	LEDs_Init();

	/* Bootloader active LED toggle timer initialization */
	TIMSK1 = (1 << TOIE1);
    73dc:	c0 93 6f 00 	sts	0x006F, r28
	TCCR1B = ((1 << CS11) | (1 << CS10));
    73e0:	83 e0       	ldi	r24, 0x03	; 3
    73e2:	80 93 81 00 	sts	0x0081, r24
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    73e6:	78 94       	sei

	/* Enable global interrupts so that the USB stack can function */
	GlobalInterruptEnable();

	/* Run the USB management task while the bootloader is supposed to be running */
	while (RunBootloader || WaitForExit)
    73e8:	80 91 01 01 	lds	r24, 0x0101
    73ec:	81 11       	cpse	r24, r1
    73ee:	11 c0       	rjmp	.+34     	; 0x7412 <main+0x6e>
    73f0:	80 91 75 01 	lds	r24, 0x0175
    73f4:	81 11       	cpse	r24, r1
    73f6:	0d c0       	rjmp	.+26     	; 0x7412 <main+0x6e>

/** Resets all configured hardware required for the bootloader back to their original states. */
static void ResetHardware(void)
{
	/* Shut down the USB and other board hardware drivers */
	USB_Disable();
    73f8:	1d d3       	rcall	.+1594   	; 0x7a34 <USB_Disable>
	LEDs_Disable();

	/* Disable Bootloader active LED toggle timer */
	TIMSK1 = 0;
    73fa:	10 92 6f 00 	sts	0x006F, r1
	TCCR1B = 0;
    73fe:	10 92 81 00 	sts	0x0081, r1

	/* Relocate the interrupt vector table back to the application section */
	MCUCR = (1 << IVCE);
    7402:	81 e0       	ldi	r24, 0x01	; 1
    7404:	85 bf       	out	0x35, r24	; 53
	MCUCR = 0;
    7406:	15 be       	out	0x35, r1	; 53

	/* Reset configured hardware back to their original states for the user application */
	ResetHardware();

	/* Start the user application */
	AppStartPtr();
    7408:	e0 91 69 01 	lds	r30, 0x0169
    740c:	f0 91 6a 01 	lds	r31, 0x016A
    7410:	09 95       	icall
	/* Enable global interrupts so that the USB stack can function */
	GlobalInterruptEnable();

	/* Run the USB management task while the bootloader is supposed to be running */
	while (RunBootloader || WaitForExit)
	  USB_USBTask();
    7412:	b6 d4       	rcall	.+2412   	; 0x7d80 <USB_USBTask>
    7414:	e9 cf       	rjmp	.-46     	; 0x73e8 <main+0x44>

00007416 <__vector_18>:
	MCUCR = 0;
}

/** ISR to periodically toggle the LEDs on the board to indicate that the bootloader is active. */
ISR(TIMER1_OVF_vect, ISR_BLOCK)
{
    7416:	1f 92       	push	r1
    7418:	0f 92       	push	r0
    741a:	0f b6       	in	r0, 0x3f	; 63
    741c:	0f 92       	push	r0
    741e:	11 24       	eor	r1, r1
	LEDs_ToggleLEDs(LEDS_LED1 | LEDS_LED2);
}
    7420:	0f 90       	pop	r0
    7422:	0f be       	out	0x3f, r0	; 63
    7424:	0f 90       	pop	r0
    7426:	1f 90       	pop	r1
    7428:	18 95       	reti

0000742a <EVENT_USB_Device_ControlRequest>:
/** Event handler for the USB_ControlRequest event. This is used to catch and process control requests sent to
 *  the device from the USB host before passing along unhandled control requests to the library for processing
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
    742a:	8f 92       	push	r8
    742c:	9f 92       	push	r9
    742e:	af 92       	push	r10
    7430:	bf 92       	push	r11
    7432:	cf 92       	push	r12
    7434:	df 92       	push	r13
    7436:	ef 92       	push	r14
    7438:	ff 92       	push	r15
    743a:	0f 93       	push	r16
    743c:	1f 93       	push	r17
    743e:	cf 93       	push	r28
    7440:	df 93       	push	r29
	/* Ignore any requests that aren't directed to the DFU interface */
	if ((USB_ControlRequest.bmRequestType & (CONTROL_REQTYPE_TYPE | CONTROL_REQTYPE_RECIPIENT)) !=
    7442:	80 91 79 01 	lds	r24, 0x0179
    7446:	8f 77       	andi	r24, 0x7F	; 127
    7448:	81 32       	cpi	r24, 0x21	; 33
    744a:	99 f4       	brne	.+38     	; 0x7472 <EVENT_USB_Device_ControlRequest+0x48>

	/* Activity - toggle indicator LEDs */
	LEDs_ToggleLEDs(LEDS_LED1 | LEDS_LED2);

	/* Get the size of the command and data from the wLength value */
	SentCommand.DataSize = USB_ControlRequest.wLength;
    744c:	80 91 7f 01 	lds	r24, 0x017F
    7450:	90 91 80 01 	lds	r25, 0x0180
    7454:	90 93 73 01 	sts	0x0173, r25
    7458:	80 93 72 01 	sts	0x0172, r24

	switch (USB_ControlRequest.bRequest)
    745c:	80 91 7a 01 	lds	r24, 0x017A
    7460:	83 30       	cpi	r24, 0x03	; 3
    7462:	09 f4       	brne	.+2      	; 0x7466 <EVENT_USB_Device_ControlRequest+0x3c>
    7464:	a7 c1       	rjmp	.+846    	; 0x77b4 <EVENT_USB_Device_ControlRequest+0x38a>
    7466:	90 f4       	brcc	.+36     	; 0x748c <EVENT_USB_Device_ControlRequest+0x62>
    7468:	81 30       	cpi	r24, 0x01	; 1
    746a:	01 f1       	breq	.+64     	; 0x74ac <EVENT_USB_Device_ControlRequest+0x82>
    746c:	82 30       	cpi	r24, 0x02	; 2
    746e:	09 f4       	brne	.+2      	; 0x7472 <EVENT_USB_Device_ControlRequest+0x48>
    7470:	14 c1       	rjmp	.+552    	; 0x769a <EVENT_USB_Device_ControlRequest+0x270>
			DFU_State = dfuIDLE;

			Endpoint_ClearStatusStage();
			break;
	}
}
    7472:	df 91       	pop	r29
    7474:	cf 91       	pop	r28
    7476:	1f 91       	pop	r17
    7478:	0f 91       	pop	r16
    747a:	ff 90       	pop	r15
    747c:	ef 90       	pop	r14
    747e:	df 90       	pop	r13
    7480:	cf 90       	pop	r12
    7482:	bf 90       	pop	r11
    7484:	af 90       	pop	r10
    7486:	9f 90       	pop	r9
    7488:	8f 90       	pop	r8
    748a:	08 95       	ret
	LEDs_ToggleLEDs(LEDS_LED1 | LEDS_LED2);

	/* Get the size of the command and data from the wLength value */
	SentCommand.DataSize = USB_ControlRequest.wLength;

	switch (USB_ControlRequest.bRequest)
    748c:	85 30       	cpi	r24, 0x05	; 5
    748e:	09 f4       	brne	.+2      	; 0x7492 <EVENT_USB_Device_ControlRequest+0x68>
    7490:	b7 c1       	rjmp	.+878    	; 0x7800 <EVENT_USB_Device_ControlRequest+0x3d6>
    7492:	08 f4       	brcc	.+2      	; 0x7496 <EVENT_USB_Device_ControlRequest+0x6c>
    7494:	ad c1       	rjmp	.+858    	; 0x77f0 <EVENT_USB_Device_ControlRequest+0x3c6>
    7496:	86 30       	cpi	r24, 0x06	; 6
    7498:	61 f7       	brne	.-40     	; 0x7472 <EVENT_USB_Device_ControlRequest+0x48>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    749a:	80 91 e8 00 	lds	r24, 0x00E8
    749e:	87 7f       	andi	r24, 0xF7	; 247
    74a0:	80 93 e8 00 	sts	0x00E8, r24
			break;
		case DFU_REQ_ABORT:
			Endpoint_ClearSETUP();

			/* Reset the current state variable to the default idle state */
			DFU_State = dfuIDLE;
    74a4:	82 e0       	ldi	r24, 0x02	; 2
    74a6:	80 93 00 01 	sts	0x0100, r24
    74aa:	25 c0       	rjmp	.+74     	; 0x74f6 <EVENT_USB_Device_ControlRequest+0xcc>
    74ac:	80 91 e8 00 	lds	r24, 0x00E8
    74b0:	87 7f       	andi	r24, 0xF7	; 247
    74b2:	80 93 e8 00 	sts	0x00E8, r24
	{
		case DFU_REQ_DNLOAD:
			Endpoint_ClearSETUP();

			/* Check if bootloader is waiting to terminate */
			if (WaitForExit)
    74b6:	80 91 75 01 	lds	r24, 0x0175
    74ba:	88 23       	and	r24, r24
    74bc:	19 f0       	breq	.+6      	; 0x74c4 <EVENT_USB_Device_ControlRequest+0x9a>
			{
				/* Bootloader is terminating - process last received command */
				ProcessBootloaderCommand();
    74be:	67 de       	rcall	.-818    	; 0x718e <ProcessBootloaderCommand>

				/* Indicate that the last command has now been processed - free to exit bootloader */
				WaitForExit = false;
    74c0:	10 92 75 01 	sts	0x0175, r1
			}

			/* If the request has a data stage, load it into the command struct */
			if (SentCommand.DataSize)
    74c4:	80 91 72 01 	lds	r24, 0x0172
    74c8:	90 91 73 01 	lds	r25, 0x0173
    74cc:	00 97       	sbiw	r24, 0x00	; 0
    74ce:	21 f5       	brne	.+72     	; 0x7518 <EVENT_USB_Device_ControlRequest+0xee>
				/* Process the command */
				ProcessBootloaderCommand();
			}

			/* Check if currently downloading firmware */
			if (DFU_State == dfuDNLOAD_IDLE)
    74d0:	80 91 00 01 	lds	r24, 0x0100
    74d4:	85 30       	cpi	r24, 0x05	; 5
    74d6:	51 f4       	brne	.+20     	; 0x74ec <EVENT_USB_Device_ControlRequest+0xc2>
			{
				if (!(SentCommand.DataSize))
    74d8:	80 91 72 01 	lds	r24, 0x0172
    74dc:	90 91 73 01 	lds	r25, 0x0173
    74e0:	89 2b       	or	r24, r25
    74e2:	09 f0       	breq	.+2      	; 0x74e6 <EVENT_USB_Device_ControlRequest+0xbc>
    74e4:	3e c0       	rjmp	.+124    	; 0x7562 <EVENT_USB_Device_ControlRequest+0x138>
				{
					DFU_State = dfuIDLE;
    74e6:	82 e0       	ldi	r24, 0x02	; 2
    74e8:	80 93 00 01 	sts	0x0100, r24
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);
    74ec:	80 91 e8 00 	lds	r24, 0x00E8
    74f0:	8b 7f       	andi	r24, 0xFB	; 251
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    74f2:	80 93 e8 00 	sts	0x00E8, r24
			DFU_State = dfuIDLE;

			Endpoint_ClearStatusStage();
			break;
	}
}
    74f6:	df 91       	pop	r29
    74f8:	cf 91       	pop	r28
    74fa:	1f 91       	pop	r17
    74fc:	0f 91       	pop	r16
    74fe:	ff 90       	pop	r15
    7500:	ef 90       	pop	r14
    7502:	df 90       	pop	r13
    7504:	cf 90       	pop	r12
    7506:	bf 90       	pop	r11
    7508:	af 90       	pop	r10
    750a:	9f 90       	pop	r9
    750c:	8f 90       	pop	r8
			Endpoint_ClearSETUP();

			/* Reset the current state variable to the default idle state */
			DFU_State = dfuIDLE;

			Endpoint_ClearStatusStage();
    750e:	75 c2       	rjmp	.+1258   	; 0x79fa <Endpoint_ClearStatusStage>
			/* If the request has a data stage, load it into the command struct */
			if (SentCommand.DataSize)
			{
				while (!(Endpoint_IsOUTReceived()))
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
    7510:	2e b3       	in	r18, 0x1e	; 30
    7512:	22 23       	and	r18, r18
    7514:	09 f4       	brne	.+2      	; 0x7518 <EVENT_USB_Device_ControlRequest+0xee>
    7516:	ad cf       	rjmp	.-166    	; 0x7472 <EVENT_USB_Device_ControlRequest+0x48>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7518:	20 91 e8 00 	lds	r18, 0x00E8
			}

			/* If the request has a data stage, load it into the command struct */
			if (SentCommand.DataSize)
			{
				while (!(Endpoint_IsOUTReceived()))
    751c:	22 ff       	sbrs	r18, 2
    751e:	f8 cf       	rjmp	.-16     	; 0x7510 <EVENT_USB_Device_ControlRequest+0xe6>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    7520:	20 91 f1 00 	lds	r18, 0x00F1
					if (USB_DeviceState == DEVICE_STATE_Unattached)
					  return;
				}

				/* First byte of the data stage is the DNLOAD request's command */
				SentCommand.Command = Endpoint_Read_8();
    7524:	20 93 6c 01 	sts	0x016C, r18

				/* One byte of the data stage is the command, so subtract it from the total data bytes */
				SentCommand.DataSize--;
    7528:	01 97       	sbiw	r24, 0x01	; 1
    752a:	90 93 73 01 	sts	0x0173, r25
    752e:	80 93 72 01 	sts	0x0172, r24
    7532:	ed e6       	ldi	r30, 0x6D	; 109
    7534:	f1 e0       	ldi	r31, 0x01	; 1
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    7536:	80 91 f2 00 	lds	r24, 0x00F2

				/* Load in the rest of the data stage as command parameters */
				for (uint8_t DataByte = 0; (DataByte < sizeof(SentCommand.Data)) &&
    753a:	88 23       	and	r24, r24
    753c:	81 f0       	breq	.+32     	; 0x755e <EVENT_USB_Device_ControlRequest+0x134>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    753e:	80 91 f1 00 	lds	r24, 0x00F1
				     Endpoint_BytesInEndpoint(); DataByte++)
				{
					SentCommand.Data[DataByte] = Endpoint_Read_8();
    7542:	81 93       	st	Z+, r24
					SentCommand.DataSize--;
    7544:	80 91 72 01 	lds	r24, 0x0172
    7548:	90 91 73 01 	lds	r25, 0x0173
    754c:	01 97       	sbiw	r24, 0x01	; 1
    754e:	90 93 73 01 	sts	0x0173, r25
    7552:	80 93 72 01 	sts	0x0172, r24

				/* One byte of the data stage is the command, so subtract it from the total data bytes */
				SentCommand.DataSize--;

				/* Load in the rest of the data stage as command parameters */
				for (uint8_t DataByte = 0; (DataByte < sizeof(SentCommand.Data)) &&
    7556:	21 e0       	ldi	r18, 0x01	; 1
    7558:	e2 37       	cpi	r30, 0x72	; 114
    755a:	f2 07       	cpc	r31, r18
    755c:	61 f7       	brne	.-40     	; 0x7536 <EVENT_USB_Device_ControlRequest+0x10c>
					SentCommand.Data[DataByte] = Endpoint_Read_8();
					SentCommand.DataSize--;
				}

				/* Process the command */
				ProcessBootloaderCommand();
    755e:	17 de       	rcall	.-978    	; 0x718e <ProcessBootloaderCommand>
    7560:	b7 cf       	rjmp	.-146    	; 0x74d0 <EVENT_USB_Device_ControlRequest+0xa6>
					DFU_State = dfuIDLE;
				}
				else
				{
					/* Throw away the filler bytes before the start of the firmware */
					DiscardFillerBytes(DFU_FILLER_BYTES_SIZE);
    7562:	8a e1       	ldi	r24, 0x1A	; 26
    7564:	ec dd       	rcall	.-1064   	; 0x713e <DiscardFillerBytes>

					/* Throw away the packet alignment filler bytes before the start of the firmware */
					DiscardFillerBytes(StartAddr % FIXED_CONTROL_ENDPOINT_SIZE);
    7566:	00 91 66 01 	lds	r16, 0x0166
    756a:	10 91 67 01 	lds	r17, 0x0167
    756e:	80 2f       	mov	r24, r16
    7570:	8f 71       	andi	r24, 0x1F	; 31
    7572:	e5 dd       	rcall	.-1078   	; 0x713e <DiscardFillerBytes>

					/* Calculate the number of bytes remaining to be written */
					uint16_t BytesRemaining = ((EndAddr - StartAddr) + 1);
    7574:	80 91 64 01 	lds	r24, 0x0164
    7578:	90 91 65 01 	lds	r25, 0x0165
    757c:	01 96       	adiw	r24, 0x01	; 1
    757e:	ec 01       	movw	r28, r24
    7580:	c0 1b       	sub	r28, r16
    7582:	d1 0b       	sbc	r29, r17

					if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))        // Write flash
    7584:	80 91 6d 01 	lds	r24, 0x016D
    7588:	81 11       	cpse	r24, r1
    758a:	77 c0       	rjmp	.+238    	; 0x767a <EVENT_USB_Device_ControlRequest+0x250>
					{
						/* Calculate the number of words to be written from the number of bytes to be written */
						uint16_t WordsRemaining = (BytesRemaining >> 1);
    758c:	ce 01       	movw	r24, r28
    758e:	96 95       	lsr	r25
    7590:	87 95       	ror	r24

						union
						{
							uint16_t Words[2];
							uint32_t Long;
						} CurrFlashAddress                 = {.Words = {StartAddr, Flash64KBPage}};
    7592:	a8 01       	movw	r20, r16
    7594:	20 91 68 01 	lds	r18, 0x0168
    7598:	62 2f       	mov	r22, r18
    759a:	70 e0       	ldi	r23, 0x00	; 0

						uint32_t CurrFlashPageStartAddress = CurrFlashAddress.Long;
    759c:	4a 01       	movw	r8, r20
    759e:	5b 01       	movw	r10, r22
						uint8_t  WordsInFlashPage          = 0;
    75a0:	20 e0       	ldi	r18, 0x00	; 0
									  return;
								}
							}

							/* Write the next word into the current flash page */
							boot_page_fill(CurrFlashAddress.Long, Endpoint_Read_16_LE());
    75a2:	c1 e0       	ldi	r28, 0x01	; 1

							/* See if an entire page has been written to the flash page buffer */
							if ((WordsInFlashPage == (SPM_PAGESIZE >> 1)) || !(WordsRemaining))
							{
								/* Commit the flash page to memory */
								boot_page_write(CurrFlashPageStartAddress);
    75a4:	d5 e0       	ldi	r29, 0x05	; 5
								{
									CurrFlashPageStartAddress = CurrFlashAddress.Long;
									WordsInFlashPage          = 0;

									/* Erase next page's temp buffer */
									boot_page_erase(CurrFlashAddress.Long);
    75a6:	13 e0       	ldi	r17, 0x03	; 3
						} CurrFlashAddress                 = {.Words = {StartAddr, Flash64KBPage}};

						uint32_t CurrFlashPageStartAddress = CurrFlashAddress.Long;
						uint8_t  WordsInFlashPage          = 0;

						while (WordsRemaining--)
    75a8:	00 97       	sbiw	r24, 0x00	; 0
    75aa:	79 f4       	brne	.+30     	; 0x75ca <EVENT_USB_Device_ControlRequest+0x1a0>
								}
							}
						}

						/* Once programming complete, start address equals the end address */
						StartAddr = EndAddr;
    75ac:	80 91 64 01 	lds	r24, 0x0164
    75b0:	90 91 65 01 	lds	r25, 0x0165
    75b4:	90 93 67 01 	sts	0x0167, r25
    75b8:	80 93 66 01 	sts	0x0166, r24

						/* Re-enable the RWW section of flash */
						boot_rww_enable();
    75bc:	81 e1       	ldi	r24, 0x11	; 17
    75be:	80 93 57 00 	sts	0x0057, r24
    75c2:	e8 95       	spm
							StartAddr++;
						}
					}

					/* Throw away the currently unused DFU file suffix */
					DiscardFillerBytes(DFU_FILE_SUFFIX_SIZE);
    75c4:	80 e1       	ldi	r24, 0x10	; 16
    75c6:	bb dd       	rcall	.-1162   	; 0x713e <DiscardFillerBytes>
    75c8:	91 cf       	rjmp	.-222    	; 0x74ec <EVENT_USB_Device_ControlRequest+0xc2>
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    75ca:	30 91 f2 00 	lds	r19, 0x00F2
						uint8_t  WordsInFlashPage          = 0;

						while (WordsRemaining--)
						{
							/* Check if endpoint is empty - if so clear it and wait until ready for next packet */
							if (!(Endpoint_BytesInEndpoint()))
    75ce:	33 23       	and	r19, r19
    75d0:	71 f1       	breq	.+92     	; 0x762e <EVENT_USB_Device_ControlRequest+0x204>
						} CurrFlashAddress                 = {.Words = {StartAddr, Flash64KBPage}};

						uint32_t CurrFlashPageStartAddress = CurrFlashAddress.Long;
						uint8_t  WordsInFlashPage          = 0;

						while (WordsRemaining--)
    75d2:	01 97       	sbiw	r24, 0x01	; 1
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    75d4:	e0 91 f1 00 	lds	r30, 0x00F1
				Data.Bytes[1] = UEDATX;
    75d8:	30 91 f1 00 	lds	r19, 0x00F1

				return Data.Value;
    75dc:	ae 2f       	mov	r26, r30
    75de:	b3 2f       	mov	r27, r19
									  return;
								}
							}

							/* Write the next word into the current flash page */
							boot_page_fill(CurrFlashAddress.Long, Endpoint_Read_16_LE());
    75e0:	fa 01       	movw	r30, r20
    75e2:	0d 01       	movw	r0, r26
    75e4:	c0 93 57 00 	sts	0x0057, r28
    75e8:	e8 95       	spm
    75ea:	11 24       	eor	r1, r1

							/* Adjust counters */
							WordsInFlashPage      += 1;
    75ec:	2f 5f       	subi	r18, 0xFF	; 255
							CurrFlashAddress.Long += 2;
    75ee:	6a 01       	movw	r12, r20
    75f0:	7b 01       	movw	r14, r22
    75f2:	f2 e0       	ldi	r31, 0x02	; 2
    75f4:	cf 0e       	add	r12, r31
    75f6:	d1 1c       	adc	r13, r1
    75f8:	e1 1c       	adc	r14, r1
    75fa:	f1 1c       	adc	r15, r1
    75fc:	b7 01       	movw	r22, r14
    75fe:	a6 01       	movw	r20, r12

							/* See if an entire page has been written to the flash page buffer */
							if ((WordsInFlashPage == (SPM_PAGESIZE >> 1)) || !(WordsRemaining))
    7600:	20 34       	cpi	r18, 0x40	; 64
    7602:	11 f5       	brne	.+68     	; 0x7648 <EVENT_USB_Device_ControlRequest+0x21e>
							{
								/* Commit the flash page to memory */
								boot_page_write(CurrFlashPageStartAddress);
    7604:	f4 01       	movw	r30, r8
    7606:	d0 93 57 00 	sts	0x0057, r29
    760a:	e8 95       	spm
								boot_spm_busy_wait();
    760c:	07 b6       	in	r0, 0x37	; 55
    760e:	00 fc       	sbrc	r0, 0
    7610:	fd cf       	rjmp	.-6      	; 0x760c <EVENT_USB_Device_ControlRequest+0x1e2>

								/* Check if programming incomplete */
								if (WordsRemaining)
    7612:	00 97       	sbiw	r24, 0x00	; 0
    7614:	09 f4       	brne	.+2      	; 0x7618 <EVENT_USB_Device_ControlRequest+0x1ee>
    7616:	c8 cf       	rjmp	.-112    	; 0x75a8 <EVENT_USB_Device_ControlRequest+0x17e>
								{
									CurrFlashPageStartAddress = CurrFlashAddress.Long;
									WordsInFlashPage          = 0;

									/* Erase next page's temp buffer */
									boot_page_erase(CurrFlashAddress.Long);
    7618:	f6 01       	movw	r30, r12
    761a:	10 93 57 00 	sts	0x0057, r17
    761e:	e8 95       	spm
									boot_spm_busy_wait();
    7620:	07 b6       	in	r0, 0x37	; 55
    7622:	00 fc       	sbrc	r0, 0
    7624:	fd cf       	rjmp	.-6      	; 0x7620 <EVENT_USB_Device_ControlRequest+0x1f6>

								/* Check if programming incomplete */
								if (WordsRemaining)
								{
									CurrFlashPageStartAddress = CurrFlashAddress.Long;
									WordsInFlashPage          = 0;
    7626:	20 e0       	ldi	r18, 0x00	; 0
								boot_spm_busy_wait();

								/* Check if programming incomplete */
								if (WordsRemaining)
								{
									CurrFlashPageStartAddress = CurrFlashAddress.Long;
    7628:	46 01       	movw	r8, r12
    762a:	57 01       	movw	r10, r14
    762c:	bd cf       	rjmp	.-134    	; 0x75a8 <EVENT_USB_Device_ControlRequest+0x17e>
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);
    762e:	30 91 e8 00 	lds	r19, 0x00E8
    7632:	3b 7f       	andi	r19, 0xFB	; 251
    7634:	30 93 e8 00 	sts	0x00E8, r19
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7638:	30 91 e8 00 	lds	r19, 0x00E8
							/* Check if endpoint is empty - if so clear it and wait until ready for next packet */
							if (!(Endpoint_BytesInEndpoint()))
							{
								Endpoint_ClearOUT();

								while (!(Endpoint_IsOUTReceived()))
    763c:	32 fd       	sbrc	r19, 2
    763e:	c9 cf       	rjmp	.-110    	; 0x75d2 <EVENT_USB_Device_ControlRequest+0x1a8>
								{
									if (USB_DeviceState == DEVICE_STATE_Unattached)
    7640:	3e b3       	in	r19, 0x1e	; 30
    7642:	31 11       	cpse	r19, r1
    7644:	f9 cf       	rjmp	.-14     	; 0x7638 <EVENT_USB_Device_ControlRequest+0x20e>
    7646:	15 cf       	rjmp	.-470    	; 0x7472 <EVENT_USB_Device_ControlRequest+0x48>
							/* Adjust counters */
							WordsInFlashPage      += 1;
							CurrFlashAddress.Long += 2;

							/* See if an entire page has been written to the flash page buffer */
							if ((WordsInFlashPage == (SPM_PAGESIZE >> 1)) || !(WordsRemaining))
    7648:	00 97       	sbiw	r24, 0x00	; 0
    764a:	09 f0       	breq	.+2      	; 0x764e <EVENT_USB_Device_ControlRequest+0x224>
    764c:	ad cf       	rjmp	.-166    	; 0x75a8 <EVENT_USB_Device_ControlRequest+0x17e>
    764e:	da cf       	rjmp	.-76     	; 0x7604 <EVENT_USB_Device_ControlRequest+0x1da>
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    7650:	80 91 f2 00 	lds	r24, 0x00F2
					else                                                   // Write EEPROM
					{
						while (BytesRemaining--)
						{
							/* Check if endpoint is empty - if so clear it and wait until ready for next packet */
							if (!(Endpoint_BytesInEndpoint()))
    7654:	88 23       	and	r24, r24
    7656:	a1 f0       	breq	.+40     	; 0x7680 <EVENT_USB_Device_ControlRequest+0x256>
						/* Re-enable the RWW section of flash */
						boot_rww_enable();
					}
					else                                                   // Write EEPROM
					{
						while (BytesRemaining--)
    7658:	21 97       	sbiw	r28, 0x01	; 1
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    765a:	60 91 f1 00 	lds	r22, 0x00F1
									  return;
								}
							}

							/* Read the byte from the USB interface and write to to the EEPROM */
							eeprom_update_byte((uint8_t*)StartAddr, Endpoint_Read_8());
    765e:	80 91 66 01 	lds	r24, 0x0166
    7662:	90 91 67 01 	lds	r25, 0x0167
    7666:	9c d3       	rcall	.+1848   	; 0x7da0 <eeprom_update_byte>

							/* Adjust counters */
							StartAddr++;
    7668:	80 91 66 01 	lds	r24, 0x0166
    766c:	90 91 67 01 	lds	r25, 0x0167
    7670:	01 96       	adiw	r24, 0x01	; 1
    7672:	90 93 67 01 	sts	0x0167, r25
    7676:	80 93 66 01 	sts	0x0166, r24
						/* Re-enable the RWW section of flash */
						boot_rww_enable();
					}
					else                                                   // Write EEPROM
					{
						while (BytesRemaining--)
    767a:	20 97       	sbiw	r28, 0x00	; 0
    767c:	49 f7       	brne	.-46     	; 0x7650 <EVENT_USB_Device_ControlRequest+0x226>
    767e:	a2 cf       	rjmp	.-188    	; 0x75c4 <EVENT_USB_Device_ControlRequest+0x19a>
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);
    7680:	80 91 e8 00 	lds	r24, 0x00E8
    7684:	8b 7f       	andi	r24, 0xFB	; 251
    7686:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    768a:	80 91 e8 00 	lds	r24, 0x00E8
							/* Check if endpoint is empty - if so clear it and wait until ready for next packet */
							if (!(Endpoint_BytesInEndpoint()))
							{
								Endpoint_ClearOUT();

								while (!(Endpoint_IsOUTReceived()))
    768e:	82 fd       	sbrc	r24, 2
    7690:	e3 cf       	rjmp	.-58     	; 0x7658 <EVENT_USB_Device_ControlRequest+0x22e>
								{
									if (USB_DeviceState == DEVICE_STATE_Unattached)
    7692:	8e b3       	in	r24, 0x1e	; 30
    7694:	81 11       	cpse	r24, r1
    7696:	f9 cf       	rjmp	.-14     	; 0x768a <EVENT_USB_Device_ControlRequest+0x260>
    7698:	ec ce       	rjmp	.-552    	; 0x7472 <EVENT_USB_Device_ControlRequest+0x48>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    769a:	80 91 e8 00 	lds	r24, 0x00E8
    769e:	87 7f       	andi	r24, 0xF7	; 247
    76a0:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    76a4:	80 91 e8 00 	lds	r24, 0x00E8

			break;
		case DFU_REQ_UPLOAD:
			Endpoint_ClearSETUP();

			while (!(Endpoint_IsINReady()))
    76a8:	80 ff       	sbrs	r24, 0
    76aa:	16 c0       	rjmp	.+44     	; 0x76d8 <EVENT_USB_Device_ControlRequest+0x2ae>
			{
				if (USB_DeviceState == DEVICE_STATE_Unattached)
				  return;
			}

			if (DFU_State != dfuUPLOAD_IDLE)
    76ac:	80 91 00 01 	lds	r24, 0x0100
    76b0:	89 30       	cpi	r24, 0x09	; 9
    76b2:	c9 f0       	breq	.+50     	; 0x76e6 <EVENT_USB_Device_ControlRequest+0x2bc>
			{
				if ((DFU_State == dfuERROR) && IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))       // Blank Check
    76b4:	8a 30       	cpi	r24, 0x0A	; 10
    76b6:	a1 f4       	brne	.+40     	; 0x76e0 <EVENT_USB_Device_ControlRequest+0x2b6>
    76b8:	80 91 6d 01 	lds	r24, 0x016D
    76bc:	81 30       	cpi	r24, 0x01	; 1
    76be:	81 f4       	brne	.+32     	; 0x76e0 <EVENT_USB_Device_ControlRequest+0x2b6>
				{
					/* Blank checking is performed in the DFU_DNLOAD request - if we get here we've told the host
					   that the memory isn't blank, and the host is requesting the first non-blank address */
					Endpoint_Write_16_LE(StartAddr);
    76c0:	90 91 66 01 	lds	r25, 0x0166
    76c4:	80 91 67 01 	lds	r24, 0x0167
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    76c8:	90 93 f1 00 	sts	0x00F1, r25
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    76cc:	80 93 f1 00 	sts	0x00F1, r24
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    76d0:	80 91 e8 00 	lds	r24, 0x00E8
    76d4:	8e 7f       	andi	r24, 0xFE	; 254
    76d6:	0d cf       	rjmp	.-486    	; 0x74f2 <EVENT_USB_Device_ControlRequest+0xc8>
		case DFU_REQ_UPLOAD:
			Endpoint_ClearSETUP();

			while (!(Endpoint_IsINReady()))
			{
				if (USB_DeviceState == DEVICE_STATE_Unattached)
    76d8:	8e b3       	in	r24, 0x1e	; 30
    76da:	81 11       	cpse	r24, r1
    76dc:	e3 cf       	rjmp	.-58     	; 0x76a4 <EVENT_USB_Device_ControlRequest+0x27a>
    76de:	c9 ce       	rjmp	.-622    	; 0x7472 <EVENT_USB_Device_ControlRequest+0x48>
					Endpoint_Write_16_LE(StartAddr);
				}
				else
				{
					/* Idle state upload - send response to last issued command */
					Endpoint_Write_8(ResponseByte);
    76e0:	80 91 6b 01 	lds	r24, 0x016B
    76e4:	f3 cf       	rjmp	.-26     	; 0x76cc <EVENT_USB_Device_ControlRequest+0x2a2>
				}
			}
			else
			{
				/* Determine the number of bytes remaining in the current block */
				uint16_t BytesRemaining = ((EndAddr - StartAddr) + 1);
    76e6:	20 91 66 01 	lds	r18, 0x0166
    76ea:	30 91 67 01 	lds	r19, 0x0167
    76ee:	c0 91 64 01 	lds	r28, 0x0164
    76f2:	d0 91 65 01 	lds	r29, 0x0165
    76f6:	21 96       	adiw	r28, 0x01	; 1
    76f8:	c2 1b       	sub	r28, r18
    76fa:	d3 0b       	sbc	r29, r19

				if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))            // Read FLASH
    76fc:	80 91 6d 01 	lds	r24, 0x016D
    7700:	81 11       	cpse	r24, r1
    7702:	31 c0       	rjmp	.+98     	; 0x7766 <EVENT_USB_Device_ControlRequest+0x33c>
				{
					/* Calculate the number of words to be written from the number of bytes to be written */
					uint16_t WordsRemaining = (BytesRemaining >> 1);
    7704:	d6 95       	lsr	r29
    7706:	c7 95       	ror	r28

					union
					{
						uint16_t Words[2];
						uint32_t Long;
					} CurrFlashAddress = {.Words = {StartAddr, Flash64KBPage}};
    7708:	c9 01       	movw	r24, r18
    770a:	20 91 68 01 	lds	r18, 0x0168
    770e:	a2 2f       	mov	r26, r18
    7710:	b0 e0       	ldi	r27, 0x00	; 0

					while (WordsRemaining--)
    7712:	21 97       	sbiw	r28, 0x01	; 1
    7714:	60 f4       	brcc	.+24     	; 0x772e <EVENT_USB_Device_ControlRequest+0x304>
						/* Adjust counters */
						CurrFlashAddress.Long += 2;
					}

					/* Once reading is complete, start address equals the end address */
					StartAddr = EndAddr;
    7716:	80 91 64 01 	lds	r24, 0x0164
    771a:	90 91 65 01 	lds	r25, 0x0165
    771e:	90 93 67 01 	sts	0x0167, r25
    7722:	80 93 66 01 	sts	0x0166, r24
						StartAddr++;
					}
				}

				/* Return to idle state */
				DFU_State = dfuIDLE;
    7726:	82 e0       	ldi	r24, 0x02	; 2
    7728:	80 93 00 01 	sts	0x0100, r24
    772c:	d1 cf       	rjmp	.-94     	; 0x76d0 <EVENT_USB_Device_ControlRequest+0x2a6>
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    772e:	20 91 f2 00 	lds	r18, 0x00F2
					} CurrFlashAddress = {.Words = {StartAddr, Flash64KBPage}};

					while (WordsRemaining--)
					{
						/* Check if endpoint is full - if so clear it and wait until ready for next packet */
						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
    7732:	20 32       	cpi	r18, 0x20	; 32
    7734:	59 f0       	breq	.+22     	; 0x774c <EVENT_USB_Device_ControlRequest+0x322>

						/* Read the flash word and send it via USB to the host */
						#if (FLASHEND > 0xFFFF)
							Endpoint_Write_16_LE(pgm_read_word_far(CurrFlashAddress.Long));
						#else
							Endpoint_Write_16_LE(pgm_read_word(CurrFlashAddress.Long));
    7736:	fc 01       	movw	r30, r24
    7738:	25 91       	lpm	r18, Z+
    773a:	34 91       	lpm	r19, Z
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    773c:	20 93 f1 00 	sts	0x00F1, r18
				UEDATX = (Data >> 8);
    7740:	30 93 f1 00 	sts	0x00F1, r19
						#endif

						/* Adjust counters */
						CurrFlashAddress.Long += 2;
    7744:	02 96       	adiw	r24, 0x02	; 2
    7746:	a1 1d       	adc	r26, r1
    7748:	b1 1d       	adc	r27, r1
    774a:	e3 cf       	rjmp	.-58     	; 0x7712 <EVENT_USB_Device_ControlRequest+0x2e8>
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    774c:	20 91 e8 00 	lds	r18, 0x00E8
    7750:	2e 7f       	andi	r18, 0xFE	; 254
    7752:	20 93 e8 00 	sts	0x00E8, r18
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    7756:	20 91 e8 00 	lds	r18, 0x00E8
						/* Check if endpoint is full - if so clear it and wait until ready for next packet */
						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
						{
							Endpoint_ClearIN();

							while (!(Endpoint_IsINReady()))
    775a:	20 fd       	sbrc	r18, 0
    775c:	ec cf       	rjmp	.-40     	; 0x7736 <EVENT_USB_Device_ControlRequest+0x30c>
							{
								if (USB_DeviceState == DEVICE_STATE_Unattached)
    775e:	2e b3       	in	r18, 0x1e	; 30
    7760:	21 11       	cpse	r18, r1
    7762:	f9 cf       	rjmp	.-14     	; 0x7756 <EVENT_USB_Device_ControlRequest+0x32c>
    7764:	86 ce       	rjmp	.-756    	; 0x7472 <EVENT_USB_Device_ControlRequest+0x48>
					}

					/* Once reading is complete, start address equals the end address */
					StartAddr = EndAddr;
				}
				else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x02))       // Read EEPROM
    7766:	82 30       	cpi	r24, 0x02	; 2
    7768:	f1 f6       	brne	.-68     	; 0x7726 <EVENT_USB_Device_ControlRequest+0x2fc>
				{
					while (BytesRemaining--)
    776a:	20 97       	sbiw	r28, 0x00	; 0
    776c:	e1 f2       	breq	.-72     	; 0x7726 <EVENT_USB_Device_ControlRequest+0x2fc>
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    776e:	80 91 f2 00 	lds	r24, 0x00F2
					{
						/* Check if endpoint is full - if so clear it and wait until ready for next packet */
						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
    7772:	80 32       	cpi	r24, 0x20	; 32
    7774:	91 f0       	breq	.+36     	; 0x779a <EVENT_USB_Device_ControlRequest+0x370>
								  return;
							}
						}

						/* Read the EEPROM byte and send it via USB to the host */
						Endpoint_Write_8(eeprom_read_byte((uint8_t*)StartAddr));
    7776:	80 91 66 01 	lds	r24, 0x0166
    777a:	90 91 67 01 	lds	r25, 0x0167
    777e:	08 d3       	rcall	.+1552   	; 0x7d90 <eeprom_read_byte>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    7780:	80 93 f1 00 	sts	0x00F1, r24

						/* Adjust counters */
						StartAddr++;
    7784:	80 91 66 01 	lds	r24, 0x0166
    7788:	90 91 67 01 	lds	r25, 0x0167
    778c:	01 96       	adiw	r24, 0x01	; 1
    778e:	90 93 67 01 	sts	0x0167, r25
    7792:	80 93 66 01 	sts	0x0166, r24
    7796:	21 97       	sbiw	r28, 0x01	; 1
    7798:	e8 cf       	rjmp	.-48     	; 0x776a <EVENT_USB_Device_ControlRequest+0x340>
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    779a:	80 91 e8 00 	lds	r24, 0x00E8
    779e:	8e 7f       	andi	r24, 0xFE	; 254
    77a0:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    77a4:	80 91 e8 00 	lds	r24, 0x00E8
						/* Check if endpoint is full - if so clear it and wait until ready for next packet */
						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
						{
							Endpoint_ClearIN();

							while (!(Endpoint_IsINReady()))
    77a8:	80 fd       	sbrc	r24, 0
    77aa:	e5 cf       	rjmp	.-54     	; 0x7776 <EVENT_USB_Device_ControlRequest+0x34c>
							{
								if (USB_DeviceState == DEVICE_STATE_Unattached)
    77ac:	8e b3       	in	r24, 0x1e	; 30
    77ae:	81 11       	cpse	r24, r1
    77b0:	f9 cf       	rjmp	.-14     	; 0x77a4 <EVENT_USB_Device_ControlRequest+0x37a>
    77b2:	5f ce       	rjmp	.-834    	; 0x7472 <EVENT_USB_Device_ControlRequest+0x48>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    77b4:	80 91 e8 00 	lds	r24, 0x00E8
    77b8:	87 7f       	andi	r24, 0xF7	; 247
    77ba:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    77be:	80 91 e8 00 	lds	r24, 0x00E8
			Endpoint_ClearStatusStage();
			break;
		case DFU_REQ_GETSTATUS:
			Endpoint_ClearSETUP();

			while (!(Endpoint_IsINReady()))
    77c2:	80 ff       	sbrs	r24, 0
    77c4:	11 c0       	rjmp	.+34     	; 0x77e8 <EVENT_USB_Device_ControlRequest+0x3be>
				if (USB_DeviceState == DEVICE_STATE_Unattached)
				  return;
			}

			/* Write 8-bit status value */
			Endpoint_Write_8(DFU_Status);
    77c6:	80 91 74 01 	lds	r24, 0x0174
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    77ca:	80 93 f1 00 	sts	0x00F1, r24
    77ce:	10 92 f1 00 	sts	0x00F1, r1
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    77d2:	10 92 f1 00 	sts	0x00F1, r1
				UEDATX = (Data >> 8);
    77d6:	10 92 f1 00 	sts	0x00F1, r1
			/* Write 24-bit poll timeout value */
			Endpoint_Write_8(0);
			Endpoint_Write_16_LE(0);

			/* Write 8-bit state value */
			Endpoint_Write_8(DFU_State);
    77da:	80 91 00 01 	lds	r24, 0x0100
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    77de:	80 93 f1 00 	sts	0x00F1, r24
    77e2:	10 92 f1 00 	sts	0x00F1, r1
    77e6:	74 cf       	rjmp	.-280    	; 0x76d0 <EVENT_USB_Device_ControlRequest+0x2a6>
		case DFU_REQ_GETSTATUS:
			Endpoint_ClearSETUP();

			while (!(Endpoint_IsINReady()))
			{
				if (USB_DeviceState == DEVICE_STATE_Unattached)
    77e8:	8e b3       	in	r24, 0x1e	; 30
    77ea:	81 11       	cpse	r24, r1
    77ec:	e8 cf       	rjmp	.-48     	; 0x77be <EVENT_USB_Device_ControlRequest+0x394>
    77ee:	41 ce       	rjmp	.-894    	; 0x7472 <EVENT_USB_Device_ControlRequest+0x48>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    77f0:	80 91 e8 00 	lds	r24, 0x00E8
    77f4:	87 7f       	andi	r24, 0xF7	; 247
    77f6:	80 93 e8 00 	sts	0x00E8, r24
			break;
		case DFU_REQ_CLRSTATUS:
			Endpoint_ClearSETUP();

			/* Reset the status value variable to the default OK status */
			DFU_Status = OK;
    77fa:	10 92 74 01 	sts	0x0174, r1
    77fe:	7b ce       	rjmp	.-778    	; 0x74f6 <EVENT_USB_Device_ControlRequest+0xcc>
    7800:	80 91 e8 00 	lds	r24, 0x00E8
    7804:	87 7f       	andi	r24, 0xF7	; 247
    7806:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    780a:	80 91 e8 00 	lds	r24, 0x00E8
			Endpoint_ClearStatusStage();
			break;
		case DFU_REQ_GETSTATE:
			Endpoint_ClearSETUP();

			while (!(Endpoint_IsINReady()))
    780e:	80 ff       	sbrs	r24, 0
    7810:	03 c0       	rjmp	.+6      	; 0x7818 <EVENT_USB_Device_ControlRequest+0x3ee>
				if (USB_DeviceState == DEVICE_STATE_Unattached)
				  return;
			}

			/* Write the current device state to the endpoint */
			Endpoint_Write_8(DFU_State);
    7812:	80 91 00 01 	lds	r24, 0x0100
    7816:	5a cf       	rjmp	.-332    	; 0x76cc <EVENT_USB_Device_ControlRequest+0x2a2>
		case DFU_REQ_GETSTATE:
			Endpoint_ClearSETUP();

			while (!(Endpoint_IsINReady()))
			{
				if (USB_DeviceState == DEVICE_STATE_Unattached)
    7818:	8e b3       	in	r24, 0x1e	; 30
    781a:	81 11       	cpse	r24, r1
    781c:	f6 cf       	rjmp	.-20     	; 0x780a <EVENT_USB_Device_ControlRequest+0x3e0>
    781e:	29 ce       	rjmp	.-942    	; 0x7472 <EVENT_USB_Device_ControlRequest+0x48>

00007820 <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint16_t wIndex,
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
    7820:	29 2f       	mov	r18, r25
    7822:	30 e0       	ldi	r19, 0x00	; 0
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
    7824:	22 30       	cpi	r18, 0x02	; 2
    7826:	31 05       	cpc	r19, r1
    7828:	71 f0       	breq	.+28     	; 0x7846 <CALLBACK_USB_GetDescriptor+0x26>
    782a:	23 30       	cpi	r18, 0x03	; 3
    782c:	31 05       	cpc	r19, r1
    782e:	81 f0       	breq	.+32     	; 0x7850 <CALLBACK_USB_GetDescriptor+0x30>
    7830:	21 30       	cpi	r18, 0x01	; 1
    7832:	31 05       	cpc	r19, r1
    7834:	11 f5       	brne	.+68     	; 0x787a <CALLBACK_USB_GetDescriptor+0x5a>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
    7836:	82 e1       	ldi	r24, 0x12	; 18
    7838:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
    783a:	22 e5       	ldi	r18, 0x52	; 82
    783c:	31 e0       	ldi	r19, 0x01	; 1
			}

			break;
	}

	*DescriptorAddress = Address;
    783e:	fa 01       	movw	r30, r20
    7840:	31 83       	std	Z+1, r19	; 0x01
    7842:	20 83       	st	Z, r18
	return Size;
}
    7844:	08 95       	ret
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
    7846:	8b e1       	ldi	r24, 0x1B	; 27
    7848:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
    784a:	27 e3       	ldi	r18, 0x37	; 55
    784c:	31 e0       	ldi	r19, 0x01	; 1
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
    784e:	f7 cf       	rjmp	.-18     	; 0x783e <CALLBACK_USB_GetDescriptor+0x1e>
		case DTYPE_String:
			if (DescriptorNumber == STRING_ID_Language)
    7850:	88 23       	and	r24, r24
    7852:	49 f0       	breq	.+18     	; 0x7866 <CALLBACK_USB_GetDescriptor+0x46>
			{
				Address = &LanguageString;
				Size    = LanguageString.Header.Size;
			}
			else if (DescriptorNumber == STRING_ID_Manufacturer)
    7854:	81 30       	cpi	r24, 0x01	; 1
    7856:	61 f0       	breq	.+24     	; 0x7870 <CALLBACK_USB_GetDescriptor+0x50>
			{
				Address = &ManufacturerString;
				Size    = ManufacturerString.Header.Size;
			}
			else if (DescriptorNumber == STRING_ID_Product)
    7858:	82 30       	cpi	r24, 0x02	; 2
    785a:	79 f4       	brne	.+30     	; 0x787a <CALLBACK_USB_GetDescriptor+0x5a>
			{
				Address = &ProductString;
				Size    = ProductString.Header.Size;
    785c:	82 e1       	ldi	r24, 0x12	; 18
    785e:	90 e0       	ldi	r25, 0x00	; 0
				Address = &ManufacturerString;
				Size    = ManufacturerString.Header.Size;
			}
			else if (DescriptorNumber == STRING_ID_Product)
			{
				Address = &ProductString;
    7860:	25 e0       	ldi	r18, 0x05	; 5
    7862:	31 e0       	ldi	r19, 0x01	; 1
    7864:	ec cf       	rjmp	.-40     	; 0x783e <CALLBACK_USB_GetDescriptor+0x1e>
			break;
		case DTYPE_String:
			if (DescriptorNumber == STRING_ID_Language)
			{
				Address = &LanguageString;
				Size    = LanguageString.Header.Size;
    7866:	84 e0       	ldi	r24, 0x04	; 4
    7868:	90 e0       	ldi	r25, 0x00	; 0
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			if (DescriptorNumber == STRING_ID_Language)
			{
				Address = &LanguageString;
    786a:	23 e3       	ldi	r18, 0x33	; 51
    786c:	31 e0       	ldi	r19, 0x01	; 1
    786e:	e7 cf       	rjmp	.-50     	; 0x783e <CALLBACK_USB_GetDescriptor+0x1e>
				Size    = LanguageString.Header.Size;
			}
			else if (DescriptorNumber == STRING_ID_Manufacturer)
			{
				Address = &ManufacturerString;
				Size    = ManufacturerString.Header.Size;
    7870:	88 e1       	ldi	r24, 0x18	; 24
    7872:	90 e0       	ldi	r25, 0x00	; 0
				Address = &LanguageString;
				Size    = LanguageString.Header.Size;
			}
			else if (DescriptorNumber == STRING_ID_Manufacturer)
			{
				Address = &ManufacturerString;
    7874:	29 e1       	ldi	r18, 0x19	; 25
    7876:	31 e0       	ldi	r19, 0x01	; 1
    7878:	e2 cf       	rjmp	.-60     	; 0x783e <CALLBACK_USB_GetDescriptor+0x1e>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
    787a:	80 e0       	ldi	r24, 0x00	; 0
    787c:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
    787e:	20 e0       	ldi	r18, 0x00	; 0
    7880:	30 e0       	ldi	r19, 0x00	; 0
    7882:	dd cf       	rjmp	.-70     	; 0x783e <CALLBACK_USB_GetDescriptor+0x1e>

00007884 <BootloaderAPI_ErasePage>:

#include "BootloaderAPI.h"

void BootloaderAPI_ErasePage(const uint32_t Address)
{
	boot_page_erase_safe(Address);
    7884:	07 b6       	in	r0, 0x37	; 55
    7886:	00 fc       	sbrc	r0, 0
    7888:	fd cf       	rjmp	.-6      	; 0x7884 <BootloaderAPI_ErasePage>
    788a:	f9 99       	sbic	0x1f, 1	; 31
    788c:	fe cf       	rjmp	.-4      	; 0x788a <BootloaderAPI_ErasePage+0x6>
    788e:	23 e0       	ldi	r18, 0x03	; 3
    7890:	fb 01       	movw	r30, r22
    7892:	20 93 57 00 	sts	0x0057, r18
    7896:	e8 95       	spm
	boot_spm_busy_wait();
    7898:	07 b6       	in	r0, 0x37	; 55
    789a:	00 fc       	sbrc	r0, 0
    789c:	fd cf       	rjmp	.-6      	; 0x7898 <BootloaderAPI_ErasePage+0x14>
	boot_rww_enable();
    789e:	81 e1       	ldi	r24, 0x11	; 17
    78a0:	80 93 57 00 	sts	0x0057, r24
    78a4:	e8 95       	spm
    78a6:	08 95       	ret

000078a8 <BootloaderAPI_WritePage>:
}

void BootloaderAPI_WritePage(const uint32_t Address)
{
	boot_page_write_safe(Address);
    78a8:	07 b6       	in	r0, 0x37	; 55
    78aa:	00 fc       	sbrc	r0, 0
    78ac:	fd cf       	rjmp	.-6      	; 0x78a8 <BootloaderAPI_WritePage>
    78ae:	f9 99       	sbic	0x1f, 1	; 31
    78b0:	fe cf       	rjmp	.-4      	; 0x78ae <BootloaderAPI_WritePage+0x6>
    78b2:	25 e0       	ldi	r18, 0x05	; 5
    78b4:	fb 01       	movw	r30, r22
    78b6:	20 93 57 00 	sts	0x0057, r18
    78ba:	e8 95       	spm
	boot_spm_busy_wait();
    78bc:	07 b6       	in	r0, 0x37	; 55
    78be:	00 fc       	sbrc	r0, 0
    78c0:	fd cf       	rjmp	.-6      	; 0x78bc <BootloaderAPI_WritePage+0x14>
	boot_rww_enable();
    78c2:	81 e1       	ldi	r24, 0x11	; 17
    78c4:	80 93 57 00 	sts	0x0057, r24
    78c8:	e8 95       	spm
    78ca:	08 95       	ret

000078cc <BootloaderAPI_FillWord>:
}

void BootloaderAPI_FillWord(const uint32_t Address, const uint16_t Word)
{
	boot_page_fill_safe(Address, Word);
    78cc:	07 b6       	in	r0, 0x37	; 55
    78ce:	00 fc       	sbrc	r0, 0
    78d0:	fd cf       	rjmp	.-6      	; 0x78cc <BootloaderAPI_FillWord>
    78d2:	f9 99       	sbic	0x1f, 1	; 31
    78d4:	fe cf       	rjmp	.-4      	; 0x78d2 <BootloaderAPI_FillWord+0x6>
    78d6:	21 e0       	ldi	r18, 0x01	; 1
    78d8:	fb 01       	movw	r30, r22
    78da:	0a 01       	movw	r0, r20
    78dc:	20 93 57 00 	sts	0x0057, r18
    78e0:	e8 95       	spm
    78e2:	11 24       	eor	r1, r1
    78e4:	08 95       	ret

000078e6 <BootloaderAPI_ReadSignature>:
}

uint8_t BootloaderAPI_ReadSignature(const uint16_t Address)
{
	return boot_signature_byte_get(Address);
    78e6:	21 e2       	ldi	r18, 0x21	; 33
    78e8:	fc 01       	movw	r30, r24
    78ea:	20 93 57 00 	sts	0x0057, r18
    78ee:	84 91       	lpm	r24, Z
}
    78f0:	08 95       	ret

000078f2 <BootloaderAPI_ReadFuse>:

uint8_t BootloaderAPI_ReadFuse(const uint16_t Address)
{
	return boot_lock_fuse_bits_get(Address);
    78f2:	29 e0       	ldi	r18, 0x09	; 9
    78f4:	fc 01       	movw	r30, r24
    78f6:	20 93 57 00 	sts	0x0057, r18
    78fa:	84 91       	lpm	r24, Z
}
    78fc:	08 95       	ret

000078fe <BootloaderAPI_ReadLock>:

uint8_t BootloaderAPI_ReadLock(void)
{
	return boot_lock_fuse_bits_get(GET_LOCK_BITS);
    78fe:	e1 e0       	ldi	r30, 0x01	; 1
    7900:	f0 e0       	ldi	r31, 0x00	; 0
    7902:	89 e0       	ldi	r24, 0x09	; 9
    7904:	80 93 57 00 	sts	0x0057, r24
    7908:	84 91       	lpm	r24, Z
}
    790a:	08 95       	ret

0000790c <BootloaderAPI_WriteLock>:

void BootloaderAPI_WriteLock(const uint8_t LockBits)
{
	boot_lock_bits_set_safe(LockBits);
    790c:	07 b6       	in	r0, 0x37	; 55
    790e:	00 fc       	sbrc	r0, 0
    7910:	fd cf       	rjmp	.-6      	; 0x790c <BootloaderAPI_WriteLock>
    7912:	f9 99       	sbic	0x1f, 1	; 31
    7914:	fe cf       	rjmp	.-4      	; 0x7912 <BootloaderAPI_WriteLock+0x6>
    7916:	80 95       	com	r24
    7918:	99 e0       	ldi	r25, 0x09	; 9
    791a:	e1 e0       	ldi	r30, 0x01	; 1
    791c:	f0 e0       	ldi	r31, 0x00	; 0
    791e:	08 2e       	mov	r0, r24
    7920:	90 93 57 00 	sts	0x0057, r25
    7924:	e8 95       	spm
    7926:	08 95       	ret

00007928 <Endpoint_Write_Control_Stream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    7928:	20 91 7f 01 	lds	r18, 0x017F
    792c:	30 91 80 01 	lds	r19, 0x0180
    7930:	26 17       	cp	r18, r22
    7932:	37 07       	cpc	r19, r23
    7934:	a8 f0       	brcs	.+42     	; 0x7960 <Endpoint_Write_Control_Stream_LE+0x38>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    7936:	61 15       	cp	r22, r1
    7938:	71 05       	cpc	r23, r1
    793a:	29 f4       	brne	.+10     	; 0x7946 <Endpoint_Write_Control_Stream_LE+0x1e>
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    793c:	20 91 e8 00 	lds	r18, 0x00E8
    7940:	2e 7f       	andi	r18, 0xFE	; 254
    7942:	20 93 e8 00 	sts	0x00E8, r18
    7946:	fc 01       	movw	r30, r24
    7948:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    794a:	61 15       	cp	r22, r1
    794c:	71 05       	cpc	r23, r1
    794e:	51 f4       	brne	.+20     	; 0x7964 <Endpoint_Write_Control_Stream_LE+0x3c>
    7950:	21 11       	cpse	r18, r1
    7952:	08 c0       	rjmp	.+16     	; 0x7964 <Endpoint_Write_Control_Stream_LE+0x3c>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7954:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    7958:	82 ff       	sbrs	r24, 2
    795a:	2f c0       	rjmp	.+94     	; 0x79ba <Endpoint_Write_Control_Stream_LE+0x92>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    795c:	80 e0       	ldi	r24, 0x00	; 0
    795e:	08 95       	ret
    7960:	b9 01       	movw	r22, r18
    7962:	f1 cf       	rjmp	.-30     	; 0x7946 <Endpoint_Write_Control_Stream_LE+0x1e>
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    7964:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    7966:	88 23       	and	r24, r24
    7968:	99 f1       	breq	.+102    	; 0x79d0 <Endpoint_Write_Control_Stream_LE+0xa8>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    796a:	85 30       	cpi	r24, 0x05	; 5
    796c:	99 f1       	breq	.+102    	; 0x79d4 <Endpoint_Write_Control_Stream_LE+0xac>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    796e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    7972:	83 fd       	sbrc	r24, 3
    7974:	2b c0       	rjmp	.+86     	; 0x79cc <Endpoint_Write_Control_Stream_LE+0xa4>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7976:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    797a:	82 fd       	sbrc	r24, 2
    797c:	eb cf       	rjmp	.-42     	; 0x7954 <Endpoint_Write_Control_Stream_LE+0x2c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    797e:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    7982:	80 ff       	sbrs	r24, 0
    7984:	e2 cf       	rjmp	.-60     	; 0x794a <Endpoint_Write_Control_Stream_LE+0x22>
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    7986:	80 91 f2 00 	lds	r24, 0x00F2
    798a:	90 e0       	ldi	r25, 0x00	; 0
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    798c:	61 15       	cp	r22, r1
    798e:	71 05       	cpc	r23, r1
    7990:	19 f0       	breq	.+6      	; 0x7998 <Endpoint_Write_Control_Stream_LE+0x70>
    7992:	80 32       	cpi	r24, 0x20	; 32
    7994:	91 05       	cpc	r25, r1
    7996:	50 f0       	brcs	.+20     	; 0x79ac <Endpoint_Write_Control_Stream_LE+0x84>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    7998:	21 e0       	ldi	r18, 0x01	; 1
    799a:	80 97       	sbiw	r24, 0x20	; 32
    799c:	09 f0       	breq	.+2      	; 0x79a0 <Endpoint_Write_Control_Stream_LE+0x78>
    799e:	20 e0       	ldi	r18, 0x00	; 0
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    79a0:	80 91 e8 00 	lds	r24, 0x00E8
    79a4:	8e 7f       	andi	r24, 0xFE	; 254
    79a6:	80 93 e8 00 	sts	0x00E8, r24
    79aa:	cf cf       	rjmp	.-98     	; 0x794a <Endpoint_Write_Control_Stream_LE+0x22>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    79ac:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    79ae:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    79b2:	61 50       	subi	r22, 0x01	; 1
    79b4:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    79b6:	01 96       	adiw	r24, 0x01	; 1
    79b8:	e9 cf       	rjmp	.-46     	; 0x798c <Endpoint_Write_Control_Stream_LE+0x64>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    79ba:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    79bc:	88 23       	and	r24, r24
    79be:	41 f0       	breq	.+16     	; 0x79d0 <Endpoint_Write_Control_Stream_LE+0xa8>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    79c0:	85 30       	cpi	r24, 0x05	; 5
    79c2:	41 f0       	breq	.+16     	; 0x79d4 <Endpoint_Write_Control_Stream_LE+0xac>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    79c4:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    79c8:	83 ff       	sbrs	r24, 3
    79ca:	c4 cf       	rjmp	.-120    	; 0x7954 <Endpoint_Write_Control_Stream_LE+0x2c>
		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    79cc:	81 e0       	ldi	r24, 0x01	; 1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    79ce:	08 95       	ret
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    79d0:	82 e0       	ldi	r24, 0x02	; 2
    79d2:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    79d4:	83 e0       	ldi	r24, 0x03	; 3
    79d6:	08 95       	ret

000079d8 <Endpoint_ConfigureEndpoint_Prv>:
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    79d8:	eb ee       	ldi	r30, 0xEB	; 235
    79da:	f0 e0       	ldi	r31, 0x00	; 0
    79dc:	80 81       	ld	r24, Z
    79de:	81 60       	ori	r24, 0x01	; 1
    79e0:	80 83       	st	Z, r24
    79e2:	ed ee       	ldi	r30, 0xED	; 237
    79e4:	f0 e0       	ldi	r31, 0x00	; 0
    79e6:	10 82       	st	Z, r1
    79e8:	60 93 ec 00 	sts	0x00EC, r22
    79ec:	40 83       	st	Z, r20
    79ee:	80 91 ee 00 	lds	r24, 0x00EE
    79f2:	88 1f       	adc	r24, r24
    79f4:	88 27       	eor	r24, r24
    79f6:	88 1f       	adc	r24, r24
    79f8:	08 95       	ret

000079fa <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    79fa:	80 91 79 01 	lds	r24, 0x0179
    79fe:	87 ff       	sbrs	r24, 7
    7a00:	11 c0       	rjmp	.+34     	; 0x7a24 <Endpoint_ClearStatusStage+0x2a>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7a02:	80 91 e8 00 	lds	r24, 0x00E8
	{
		while (!(Endpoint_IsOUTReceived()))
    7a06:	82 ff       	sbrs	r24, 2
    7a08:	06 c0       	rjmp	.+12     	; 0x7a16 <Endpoint_ClearStatusStage+0x1c>
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);
    7a0a:	80 91 e8 00 	lds	r24, 0x00E8
    7a0e:	8b 7f       	andi	r24, 0xFB	; 251
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    7a10:	80 93 e8 00 	sts	0x00E8, r24
    7a14:	03 c0       	rjmp	.+6      	; 0x7a1c <Endpoint_ClearStatusStage+0x22>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    7a16:	8e b3       	in	r24, 0x1e	; 30
    7a18:	81 11       	cpse	r24, r1
    7a1a:	f3 cf       	rjmp	.-26     	; 0x7a02 <Endpoint_ClearStatusStage+0x8>
    7a1c:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    7a1e:	8e b3       	in	r24, 0x1e	; 30
    7a20:	88 23       	and	r24, r24
    7a22:	e1 f3       	breq	.-8      	; 0x7a1c <Endpoint_ClearStatusStage+0x22>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    7a24:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    7a28:	80 ff       	sbrs	r24, 0
    7a2a:	f9 cf       	rjmp	.-14     	; 0x7a1e <Endpoint_ClearStatusStage+0x24>
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    7a2c:	80 91 e8 00 	lds	r24, 0x00E8
    7a30:	8e 7f       	andi	r24, 0xFE	; 254
    7a32:	ee cf       	rjmp	.-36     	; 0x7a10 <Endpoint_ClearStatusStage+0x16>

00007a34 <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    7a34:	51 d0       	rcall	.+162    	; 0x7ad8 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    7a36:	53 d0       	rcall	.+166    	; 0x7ade <USB_INT_ClearAllInterrupts>
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    7a38:	e0 ee       	ldi	r30, 0xE0	; 224
    7a3a:	f0 e0       	ldi	r31, 0x00	; 0
    7a3c:	80 81       	ld	r24, Z
    7a3e:	81 60       	ori	r24, 0x01	; 1
    7a40:	80 83       	st	Z, r24
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON &= ~(1 << USBE);
    7a42:	e8 ed       	ldi	r30, 0xD8	; 216
    7a44:	f0 e0       	ldi	r31, 0x00	; 0
    7a46:	80 81       	ld	r24, Z
    7a48:	8f 77       	andi	r24, 0x7F	; 127
    7a4a:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    7a4c:	19 bc       	out	0x29, r1	; 41
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON &= ~(1 << UVREGE);
			#else
				REGCR  |=  (1 << REGDIS);
    7a4e:	e3 e6       	ldi	r30, 0x63	; 99
    7a50:	f0 e0       	ldi	r31, 0x00	; 0
    7a52:	80 81       	ld	r24, Z
    7a54:	81 60       	ori	r24, 0x01	; 1
    7a56:	80 83       	st	Z, r24

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
    7a58:	10 92 78 01 	sts	0x0178, r1
    7a5c:	08 95       	ret

00007a5e <USB_ResetInterface>:
{
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    7a5e:	3c d0       	rcall	.+120    	; 0x7ad8 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    7a60:	3e d0       	rcall	.+124    	; 0x7ade <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    7a62:	80 91 d8 00 	lds	r24, 0x00D8
    7a66:	8f 77       	andi	r24, 0x7F	; 127
    7a68:	80 93 d8 00 	sts	0x00D8, r24
				USBCON |=  (1 << USBE);
    7a6c:	80 91 d8 00 	lds	r24, 0x00D8
    7a70:	80 68       	ori	r24, 0x80	; 128
    7a72:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    7a76:	80 91 d8 00 	lds	r24, 0x00D8
    7a7a:	8f 7d       	andi	r24, 0xDF	; 223
    7a7c:	80 93 d8 00 	sts	0x00D8, r24

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    7a80:	84 e0       	ldi	r24, 0x04	; 4
    7a82:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    7a84:	86 e0       	ldi	r24, 0x06	; 6
    7a86:	89 bd       	out	0x29, r24	; 41

		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			#if defined(USB_SERIES_2_AVR)
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    7a88:	09 b4       	in	r0, 0x29	; 41
    7a8a:	00 fe       	sbrs	r0, 0
    7a8c:	fd cf       	rjmp	.-6      	; 0x7a88 <USB_ResetInterface+0x2a>
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    7a8e:	1e ba       	out	0x1e, r1	; 30
	USB_Device_ConfigurationNumber  = 0;
    7a90:	10 92 77 01 	sts	0x0177, r1
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    7a94:	42 e2       	ldi	r20, 0x22	; 34
    7a96:	60 e0       	ldi	r22, 0x00	; 0
    7a98:	80 e0       	ldi	r24, 0x00	; 0
    7a9a:	9e df       	rcall	.-196    	; 0x79d8 <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    7a9c:	80 91 e1 00 	lds	r24, 0x00E1
    7aa0:	8e 7f       	andi	r24, 0xFE	; 254
    7aa2:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    7aa6:	80 91 e2 00 	lds	r24, 0x00E2
    7aaa:	81 60       	ori	r24, 0x01	; 1
    7aac:	80 93 e2 00 	sts	0x00E2, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    7ab0:	80 91 e2 00 	lds	r24, 0x00E2
    7ab4:	88 60       	ori	r24, 0x08	; 8
    7ab6:	80 93 e2 00 	sts	0x00E2, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    7aba:	80 91 e0 00 	lds	r24, 0x00E0
    7abe:	8e 7f       	andi	r24, 0xFE	; 254
    7ac0:	80 93 e0 00 	sts	0x00E0, r24
    7ac4:	08 95       	ret

00007ac6 <USB_Init>:
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
			#else
				REGCR  &= ~(1 << REGDIS);
    7ac6:	e3 e6       	ldi	r30, 0x63	; 99
    7ac8:	f0 e0       	ldi	r31, 0x00	; 0
    7aca:	80 81       	ld	r24, Z
    7acc:	8e 7f       	andi	r24, 0xFE	; 254
    7ace:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    7ad0:	81 e0       	ldi	r24, 0x01	; 1
    7ad2:	80 93 78 01 	sts	0x0178, r24

	USB_ResetInterface();
    7ad6:	c3 cf       	rjmp	.-122    	; 0x7a5e <USB_ResetInterface>

00007ad8 <USB_INT_DisableAllInterrupts>:
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    7ad8:	10 92 e2 00 	sts	0x00E2, r1
    7adc:	08 95       	ret

00007ade <USB_INT_ClearAllInterrupts>:
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    7ade:	10 92 e1 00 	sts	0x00E1, r1
    7ae2:	08 95       	ret

00007ae4 <__vector_11>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    7ae4:	1f 92       	push	r1
    7ae6:	0f 92       	push	r0
    7ae8:	0f b6       	in	r0, 0x3f	; 63
    7aea:	0f 92       	push	r0
    7aec:	11 24       	eor	r1, r1
    7aee:	2f 93       	push	r18
    7af0:	3f 93       	push	r19
    7af2:	4f 93       	push	r20
    7af4:	5f 93       	push	r21
    7af6:	6f 93       	push	r22
    7af8:	7f 93       	push	r23
    7afa:	8f 93       	push	r24
    7afc:	9f 93       	push	r25
    7afe:	af 93       	push	r26
    7b00:	bf 93       	push	r27
    7b02:	ef 93       	push	r30
    7b04:	ff 93       	push	r31
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    7b06:	80 91 e1 00 	lds	r24, 0x00E1
			EVENT_USB_Device_Disconnect();
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    7b0a:	80 ff       	sbrs	r24, 0
    7b0c:	16 c0       	rjmp	.+44     	; 0x7b3a <__vector_11+0x56>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    7b0e:	80 91 e2 00 	lds	r24, 0x00E2
    7b12:	80 ff       	sbrs	r24, 0
    7b14:	12 c0       	rjmp	.+36     	; 0x7b3a <__vector_11+0x56>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    7b16:	80 91 e2 00 	lds	r24, 0x00E2
    7b1a:	8e 7f       	andi	r24, 0xFE	; 254
    7b1c:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    7b20:	80 91 e2 00 	lds	r24, 0x00E2
    7b24:	80 61       	ori	r24, 0x10	; 16
    7b26:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    7b2a:	80 91 d8 00 	lds	r24, 0x00D8
    7b2e:	80 62       	ori	r24, 0x20	; 32
    7b30:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    7b34:	19 bc       	out	0x29, r1	; 41

		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		  USB_PLL_Off();

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
    7b36:	1e ba       	out	0x1e, r1	; 30
		EVENT_USB_Device_Disconnect();
    7b38:	22 d1       	rcall	.+580    	; 0x7d7e <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    7b3a:	80 91 e1 00 	lds	r24, 0x00E1
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    7b3e:	84 ff       	sbrs	r24, 4
    7b40:	26 c0       	rjmp	.+76     	; 0x7b8e <__vector_11+0xaa>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    7b42:	80 91 e2 00 	lds	r24, 0x00E2
    7b46:	84 ff       	sbrs	r24, 4
    7b48:	22 c0       	rjmp	.+68     	; 0x7b8e <__vector_11+0xaa>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    7b4a:	84 e0       	ldi	r24, 0x04	; 4
    7b4c:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    7b4e:	86 e0       	ldi	r24, 0x06	; 6
    7b50:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    7b52:	09 b4       	in	r0, 0x29	; 41
    7b54:	00 fe       	sbrs	r0, 0
    7b56:	fd cf       	rjmp	.-6      	; 0x7b52 <__vector_11+0x6e>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    7b58:	80 91 d8 00 	lds	r24, 0x00D8
    7b5c:	8f 7d       	andi	r24, 0xDF	; 223
    7b5e:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    7b62:	80 91 e1 00 	lds	r24, 0x00E1
    7b66:	8f 7e       	andi	r24, 0xEF	; 239
    7b68:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    7b6c:	80 91 e2 00 	lds	r24, 0x00E2
    7b70:	8f 7e       	andi	r24, 0xEF	; 239
    7b72:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    7b76:	80 91 e2 00 	lds	r24, 0x00E2
    7b7a:	81 60       	ori	r24, 0x01	; 1
    7b7c:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    7b80:	80 91 77 01 	lds	r24, 0x0177
    7b84:	88 23       	and	r24, r24
    7b86:	c9 f1       	breq	.+114    	; 0x7bfa <__vector_11+0x116>
		  USB_DeviceState = DEVICE_STATE_Configured;
    7b88:	84 e0       	ldi	r24, 0x04	; 4
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    7b8a:	8e bb       	out	0x1e, r24	; 30

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
    7b8c:	f8 d0       	rcall	.+496    	; 0x7d7e <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    7b8e:	80 91 e1 00 	lds	r24, 0x00E1
		#else
		EVENT_USB_Device_WakeUp();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    7b92:	83 ff       	sbrs	r24, 3
    7b94:	21 c0       	rjmp	.+66     	; 0x7bd8 <__vector_11+0xf4>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    7b96:	80 91 e2 00 	lds	r24, 0x00E2
    7b9a:	83 ff       	sbrs	r24, 3
    7b9c:	1d c0       	rjmp	.+58     	; 0x7bd8 <__vector_11+0xf4>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    7b9e:	80 91 e1 00 	lds	r24, 0x00E1
    7ba2:	87 7f       	andi	r24, 0xF7	; 247
    7ba4:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    7ba8:	82 e0       	ldi	r24, 0x02	; 2
    7baa:	8e bb       	out	0x1e, r24	; 30
		USB_Device_ConfigurationNumber = 0;
    7bac:	10 92 77 01 	sts	0x0177, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    7bb0:	80 91 e1 00 	lds	r24, 0x00E1
    7bb4:	8e 7f       	andi	r24, 0xFE	; 254
    7bb6:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    7bba:	80 91 e2 00 	lds	r24, 0x00E2
    7bbe:	8e 7f       	andi	r24, 0xFE	; 254
    7bc0:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    7bc4:	80 91 e2 00 	lds	r24, 0x00E2
    7bc8:	80 61       	ori	r24, 0x10	; 16
    7bca:	80 93 e2 00 	sts	0x00E2, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    7bce:	42 e2       	ldi	r20, 0x22	; 34
    7bd0:	60 e0       	ldi	r22, 0x00	; 0
    7bd2:	80 e0       	ldi	r24, 0x00	; 0
    7bd4:	01 df       	rcall	.-510    	; 0x79d8 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    7bd6:	d3 d0       	rcall	.+422    	; 0x7d7e <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    7bd8:	ff 91       	pop	r31
    7bda:	ef 91       	pop	r30
    7bdc:	bf 91       	pop	r27
    7bde:	af 91       	pop	r26
    7be0:	9f 91       	pop	r25
    7be2:	8f 91       	pop	r24
    7be4:	7f 91       	pop	r23
    7be6:	6f 91       	pop	r22
    7be8:	5f 91       	pop	r21
    7bea:	4f 91       	pop	r20
    7bec:	3f 91       	pop	r19
    7bee:	2f 91       	pop	r18
    7bf0:	0f 90       	pop	r0
    7bf2:	0f be       	out	0x3f, r0	; 63
    7bf4:	0f 90       	pop	r0
    7bf6:	1f 90       	pop	r1
    7bf8:	18 95       	reti
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    7bfa:	80 91 e3 00 	lds	r24, 0x00E3
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    7bfe:	87 fd       	sbrc	r24, 7
    7c00:	02 c0       	rjmp	.+4      	; 0x7c06 <__vector_11+0x122>
    7c02:	81 e0       	ldi	r24, 0x01	; 1
    7c04:	c2 cf       	rjmp	.-124    	; 0x7b8a <__vector_11+0xa6>
    7c06:	83 e0       	ldi	r24, 0x03	; 3
    7c08:	c0 cf       	rjmp	.-128    	; 0x7b8a <__vector_11+0xa6>

00007c0a <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    7c0a:	1f 93       	push	r17
    7c0c:	cf 93       	push	r28
    7c0e:	df 93       	push	r29
    7c10:	00 d0       	rcall	.+0      	; 0x7c12 <USB_Device_ProcessControlRequest+0x8>
    7c12:	cd b7       	in	r28, 0x3d	; 61
    7c14:	de b7       	in	r29, 0x3e	; 62
    7c16:	e9 e7       	ldi	r30, 0x79	; 121
    7c18:	f1 e0       	ldi	r31, 0x01	; 1
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    7c1a:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    7c1e:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    7c20:	81 e0       	ldi	r24, 0x01	; 1
    7c22:	e1 38       	cpi	r30, 0x81	; 129
    7c24:	f8 07       	cpc	r31, r24
    7c26:	c9 f7       	brne	.-14     	; 0x7c1a <USB_Device_ProcessControlRequest+0x10>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    7c28:	00 dc       	rcall	.-2048   	; 0x742a <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7c2a:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    7c2e:	83 ff       	sbrs	r24, 3
    7c30:	0d c0       	rjmp	.+26     	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    7c32:	80 91 79 01 	lds	r24, 0x0179

		switch (USB_ControlRequest.bRequest)
    7c36:	90 91 7a 01 	lds	r25, 0x017A
    7c3a:	96 30       	cpi	r25, 0x06	; 6
    7c3c:	09 f4       	brne	.+2      	; 0x7c40 <USB_Device_ProcessControlRequest+0x36>
    7c3e:	68 c0       	rjmp	.+208    	; 0x7d10 <USB_Device_ProcessControlRequest+0x106>
    7c40:	c8 f4       	brcc	.+50     	; 0x7c74 <USB_Device_ProcessControlRequest+0x6a>
    7c42:	99 23       	and	r25, r25
    7c44:	89 f1       	breq	.+98     	; 0x7ca8 <USB_Device_ProcessControlRequest+0x9e>
    7c46:	95 30       	cpi	r25, 0x05	; 5
    7c48:	09 f4       	brne	.+2      	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
    7c4a:	41 c0       	rjmp	.+130    	; 0x7cce <USB_Device_ProcessControlRequest+0xc4>
    7c4c:	80 91 e8 00 	lds	r24, 0x00E8
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    7c50:	83 ff       	sbrs	r24, 3
    7c52:	0a c0       	rjmp	.+20     	; 0x7c68 <USB_Device_ProcessControlRequest+0x5e>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7c54:	80 91 e8 00 	lds	r24, 0x00E8
    7c58:	87 7f       	andi	r24, 0xF7	; 247
    7c5a:	80 93 e8 00 	sts	0x00E8, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    7c5e:	80 91 eb 00 	lds	r24, 0x00EB
    7c62:	80 62       	ori	r24, 0x20	; 32
    7c64:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    7c68:	0f 90       	pop	r0
    7c6a:	0f 90       	pop	r0
    7c6c:	df 91       	pop	r29
    7c6e:	cf 91       	pop	r28
    7c70:	1f 91       	pop	r17
    7c72:	08 95       	ret

	if (Endpoint_IsSETUPReceived())
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;

		switch (USB_ControlRequest.bRequest)
    7c74:	98 30       	cpi	r25, 0x08	; 8
    7c76:	09 f4       	brne	.+2      	; 0x7c7a <USB_Device_ProcessControlRequest+0x70>
    7c78:	6d c0       	rjmp	.+218    	; 0x7d54 <USB_Device_ProcessControlRequest+0x14a>
    7c7a:	99 30       	cpi	r25, 0x09	; 9
    7c7c:	39 f7       	brne	.-50     	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    7c7e:	81 11       	cpse	r24, r1
    7c80:	e5 cf       	rjmp	.-54     	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    7c82:	90 91 7b 01 	lds	r25, 0x017B
    7c86:	92 30       	cpi	r25, 0x02	; 2
    7c88:	08 f7       	brcc	.-62     	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7c8a:	80 91 e8 00 	lds	r24, 0x00E8
    7c8e:	87 7f       	andi	r24, 0xF7	; 247
    7c90:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    7c94:	90 93 77 01 	sts	0x0177, r25

	Endpoint_ClearStatusStage();
    7c98:	b0 de       	rcall	.-672    	; 0x79fa <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    7c9a:	80 91 77 01 	lds	r24, 0x0177
    7c9e:	88 23       	and	r24, r24
    7ca0:	09 f4       	brne	.+2      	; 0x7ca4 <USB_Device_ProcessControlRequest+0x9a>
    7ca2:	65 c0       	rjmp	.+202    	; 0x7d6e <USB_Device_ProcessControlRequest+0x164>
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    7ca4:	84 e0       	ldi	r24, 0x04	; 4
    7ca6:	68 c0       	rjmp	.+208    	; 0x7d78 <USB_Device_ProcessControlRequest+0x16e>
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;

		switch (USB_ControlRequest.bRequest)
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    7ca8:	8d 7f       	andi	r24, 0xFD	; 253
    7caa:	80 38       	cpi	r24, 0x80	; 128
    7cac:	79 f6       	brne	.-98     	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
    7cae:	80 91 e8 00 	lds	r24, 0x00E8
    7cb2:	87 7f       	andi	r24, 0xF7	; 247
    7cb4:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    7cb8:	10 92 f1 00 	sts	0x00F1, r1
				UEDATX = (Data >> 8);
    7cbc:	10 92 f1 00 	sts	0x00F1, r1
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << TXINI);
    7cc0:	80 91 e8 00 	lds	r24, 0x00E8
    7cc4:	8e 7f       	andi	r24, 0xFE	; 254
    7cc6:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    7cca:	97 de       	rcall	.-722    	; 0x79fa <Endpoint_ClearStatusStage>
    7ccc:	bf cf       	rjmp	.-130    	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    7cce:	81 11       	cpse	r24, r1
    7cd0:	bd cf       	rjmp	.-134    	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    7cd2:	10 91 7b 01 	lds	r17, 0x017B
    7cd6:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    7cd8:	80 91 e3 00 	lds	r24, 0x00E3
    7cdc:	80 78       	andi	r24, 0x80	; 128
    7cde:	81 2b       	or	r24, r17
    7ce0:	80 93 e3 00 	sts	0x00E3, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7ce4:	80 91 e8 00 	lds	r24, 0x00E8
    7ce8:	87 7f       	andi	r24, 0xF7	; 247
    7cea:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    7cee:	85 de       	rcall	.-758    	; 0x79fa <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    7cf0:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    7cf4:	80 ff       	sbrs	r24, 0
    7cf6:	fc cf       	rjmp	.-8      	; 0x7cf0 <USB_Device_ProcessControlRequest+0xe6>
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
    7cf8:	80 91 e3 00 	lds	r24, 0x00E3
    7cfc:	80 68       	ori	r24, 0x80	; 128
    7cfe:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    7d02:	11 11       	cpse	r17, r1
    7d04:	03 c0       	rjmp	.+6      	; 0x7d0c <USB_Device_ProcessControlRequest+0x102>
    7d06:	82 e0       	ldi	r24, 0x02	; 2
    7d08:	8e bb       	out	0x1e, r24	; 30
    7d0a:	a0 cf       	rjmp	.-192    	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
    7d0c:	83 e0       	ldi	r24, 0x03	; 3
    7d0e:	fc cf       	rjmp	.-8      	; 0x7d08 <USB_Device_ProcessControlRequest+0xfe>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    7d10:	80 58       	subi	r24, 0x80	; 128
    7d12:	82 30       	cpi	r24, 0x02	; 2
    7d14:	08 f0       	brcs	.+2      	; 0x7d18 <USB_Device_ProcessControlRequest+0x10e>
    7d16:	9a cf       	rjmp	.-204    	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    7d18:	60 91 7d 01 	lds	r22, 0x017D
    7d1c:	70 91 7e 01 	lds	r23, 0x017E
    7d20:	ae 01       	movw	r20, r28
    7d22:	4f 5f       	subi	r20, 0xFF	; 255
    7d24:	5f 4f       	sbci	r21, 0xFF	; 255
    7d26:	80 91 7b 01 	lds	r24, 0x017B
    7d2a:	90 91 7c 01 	lds	r25, 0x017C
    7d2e:	78 dd       	rcall	.-1296   	; 0x7820 <CALLBACK_USB_GetDescriptor>
    7d30:	bc 01       	movw	r22, r24
    7d32:	89 2b       	or	r24, r25
    7d34:	09 f4       	brne	.+2      	; 0x7d38 <USB_Device_ProcessControlRequest+0x12e>
    7d36:	8a cf       	rjmp	.-236    	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7d38:	90 91 e8 00 	lds	r25, 0x00E8
    7d3c:	97 7f       	andi	r25, 0xF7	; 247
    7d3e:	90 93 e8 00 	sts	0x00E8, r25
	}

	Endpoint_ClearSETUP();

	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
    7d42:	89 81       	ldd	r24, Y+1	; 0x01
    7d44:	9a 81       	ldd	r25, Y+2	; 0x02
    7d46:	f0 dd       	rcall	.-1056   	; 0x7928 <Endpoint_Write_Control_Stream_LE>
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);
    7d48:	80 91 e8 00 	lds	r24, 0x00E8
    7d4c:	8b 7f       	andi	r24, 0xFB	; 251
    7d4e:	80 93 e8 00 	sts	0x00E8, r24
    7d52:	7c cf       	rjmp	.-264    	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    7d54:	80 38       	cpi	r24, 0x80	; 128
    7d56:	09 f0       	breq	.+2      	; 0x7d5a <USB_Device_ProcessControlRequest+0x150>
    7d58:	79 cf       	rjmp	.-270    	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7d5a:	80 91 e8 00 	lds	r24, 0x00E8
    7d5e:	87 7f       	andi	r24, 0xF7	; 247
    7d60:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    7d64:	80 91 77 01 	lds	r24, 0x0177
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    7d68:	80 93 f1 00 	sts	0x00F1, r24
    7d6c:	a9 cf       	rjmp	.-174    	; 0x7cc0 <USB_Device_ProcessControlRequest+0xb6>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    7d6e:	80 91 e3 00 	lds	r24, 0x00E3
	Endpoint_ClearStatusStage();

	if (USB_Device_ConfigurationNumber)
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    7d72:	87 fd       	sbrc	r24, 7
    7d74:	97 cf       	rjmp	.-210    	; 0x7ca4 <USB_Device_ProcessControlRequest+0x9a>
    7d76:	81 e0       	ldi	r24, 0x01	; 1
    7d78:	8e bb       	out	0x1e, r24	; 30

	EVENT_USB_Device_ConfigurationChanged();
    7d7a:	01 d0       	rcall	.+2      	; 0x7d7e <USB_Event_Stub>
    7d7c:	67 cf       	rjmp	.-306    	; 0x7c4c <USB_Device_ProcessControlRequest+0x42>

00007d7e <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    7d7e:	08 95       	ret

00007d80 <USB_USBTask>:
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    7d80:	8e b3       	in	r24, 0x1e	; 30
    7d82:	88 23       	and	r24, r24
    7d84:	21 f0       	breq	.+8      	; 0x7d8e <USB_USBTask+0xe>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7d86:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    7d8a:	83 fd       	sbrc	r24, 3
	  USB_Device_ProcessControlRequest();
    7d8c:	3e cf       	rjmp	.-388    	; 0x7c0a <USB_Device_ProcessControlRequest>
    7d8e:	08 95       	ret

00007d90 <eeprom_read_byte>:
    7d90:	f9 99       	sbic	0x1f, 1	; 31
    7d92:	fe cf       	rjmp	.-4      	; 0x7d90 <eeprom_read_byte>
    7d94:	92 bd       	out	0x22, r25	; 34
    7d96:	81 bd       	out	0x21, r24	; 33
    7d98:	f8 9a       	sbi	0x1f, 0	; 31
    7d9a:	99 27       	eor	r25, r25
    7d9c:	80 b5       	in	r24, 0x20	; 32
    7d9e:	08 95       	ret

00007da0 <eeprom_update_byte>:
    7da0:	26 2f       	mov	r18, r22

00007da2 <eeprom_update_r18>:
    7da2:	f9 99       	sbic	0x1f, 1	; 31
    7da4:	fe cf       	rjmp	.-4      	; 0x7da2 <eeprom_update_r18>
    7da6:	92 bd       	out	0x22, r25	; 34
    7da8:	81 bd       	out	0x21, r24	; 33
    7daa:	f8 9a       	sbi	0x1f, 0	; 31
    7dac:	01 97       	sbiw	r24, 0x01	; 1
    7dae:	00 b4       	in	r0, 0x20	; 32
    7db0:	02 16       	cp	r0, r18
    7db2:	39 f0       	breq	.+14     	; 0x7dc2 <eeprom_update_r18+0x20>
    7db4:	1f ba       	out	0x1f, r1	; 31
    7db6:	20 bd       	out	0x20, r18	; 32
    7db8:	0f b6       	in	r0, 0x3f	; 63
    7dba:	f8 94       	cli
    7dbc:	fa 9a       	sbi	0x1f, 2	; 31
    7dbe:	f9 9a       	sbi	0x1f, 1	; 31
    7dc0:	0f be       	out	0x3f, r0	; 63
    7dc2:	08 95       	ret

00007dc4 <_exit>:
    7dc4:	f8 94       	cli

00007dc6 <__stop_program>:
    7dc6:	ff cf       	rjmp	.-2      	; 0x7dc6 <__stop_program>

Disassembly of section .apitable_trampolines:

00007fa0 <BootloaderAPI_Trampolines>:
.section .apitable_trampolines, "ax"
.global BootloaderAPI_Trampolines
BootloaderAPI_Trampolines:

	BootloaderAPI_ErasePage_Trampoline:
		jmp BootloaderAPI_ErasePage
    7fa0:	71 cc       	rjmp	.-1822   	; 0x7884 <BootloaderAPI_ErasePage>

00007fa2 <BootloaderAPI_WritePage_Trampoline>:
	BootloaderAPI_WritePage_Trampoline:
		jmp BootloaderAPI_WritePage
    7fa2:	82 cc       	rjmp	.-1788   	; 0x78a8 <BootloaderAPI_WritePage>

00007fa4 <BootloaderAPI_FillWord_Trampoline>:
	BootloaderAPI_FillWord_Trampoline:
		jmp BootloaderAPI_FillWord
    7fa4:	93 cc       	rjmp	.-1754   	; 0x78cc <BootloaderAPI_FillWord>

00007fa6 <BootloaderAPI_ReadSignature_Trampoline>:
	BootloaderAPI_ReadSignature_Trampoline:
		jmp BootloaderAPI_ReadSignature
    7fa6:	9f cc       	rjmp	.-1730   	; 0x78e6 <BootloaderAPI_ReadSignature>

00007fa8 <BootloaderAPI_ReadFuse_Trampoline>:
	BootloaderAPI_ReadFuse_Trampoline:
		jmp BootloaderAPI_ReadFuse
    7fa8:	a4 cc       	rjmp	.-1720   	; 0x78f2 <BootloaderAPI_ReadFuse>

00007faa <BootloaderAPI_ReadLock_Trampoline>:
	BootloaderAPI_ReadLock_Trampoline:
		jmp BootloaderAPI_ReadLock
    7faa:	a9 cc       	rjmp	.-1710   	; 0x78fe <BootloaderAPI_ReadLock>

00007fac <BootloaderAPI_WriteLock_Trampoline>:
	BootloaderAPI_WriteLock_Trampoline:
		jmp BootloaderAPI_WriteLock
    7fac:	af cc       	rjmp	.-1698   	; 0x790c <BootloaderAPI_WriteLock>

00007fae <BootloaderAPI_UNUSED1>:
	BootloaderAPI_UNUSED1:
		ret
    7fae:	08 95       	ret

00007fb0 <BootloaderAPI_UNUSED2>:
	BootloaderAPI_UNUSED2:
		ret
    7fb0:	08 95       	ret

00007fb2 <BootloaderAPI_UNUSED3>:
	BootloaderAPI_UNUSED3:
		ret
    7fb2:	08 95       	ret

00007fb4 <BootloaderAPI_UNUSED4>:
	BootloaderAPI_UNUSED4:
		ret
    7fb4:	08 95       	ret

00007fb6 <BootloaderAPI_UNUSED5>:
	BootloaderAPI_UNUSED5:
		ret
    7fb6:	08 95       	ret

Disassembly of section .apitable_jumptable:

00007fe0 <BootloaderAPI_JumpTable>:
; API function jump table
.section .apitable_jumptable, "ax"
.global BootloaderAPI_JumpTable
BootloaderAPI_JumpTable:

	rjmp BootloaderAPI_ErasePage_Trampoline
    7fe0:	df cf       	rjmp	.-66     	; 0x7fa0 <BootloaderAPI_Trampolines>
	rjmp BootloaderAPI_WritePage_Trampoline
    7fe2:	df cf       	rjmp	.-66     	; 0x7fa2 <BootloaderAPI_WritePage_Trampoline>
	rjmp BootloaderAPI_FillWord_Trampoline
    7fe4:	df cf       	rjmp	.-66     	; 0x7fa4 <BootloaderAPI_FillWord_Trampoline>
	rjmp BootloaderAPI_ReadSignature_Trampoline
    7fe6:	df cf       	rjmp	.-66     	; 0x7fa6 <BootloaderAPI_ReadSignature_Trampoline>
	rjmp BootloaderAPI_ReadFuse_Trampoline
    7fe8:	df cf       	rjmp	.-66     	; 0x7fa8 <BootloaderAPI_ReadFuse_Trampoline>
	rjmp BootloaderAPI_ReadLock_Trampoline
    7fea:	df cf       	rjmp	.-66     	; 0x7faa <BootloaderAPI_ReadLock_Trampoline>
	rjmp BootloaderAPI_WriteLock_Trampoline
    7fec:	df cf       	rjmp	.-66     	; 0x7fac <BootloaderAPI_WriteLock_Trampoline>
	rjmp BootloaderAPI_UNUSED1 ; UNUSED ENTRY 1
    7fee:	df cf       	rjmp	.-66     	; 0x7fae <BootloaderAPI_UNUSED1>
	rjmp BootloaderAPI_UNUSED2 ; UNUSED ENTRY 2
    7ff0:	df cf       	rjmp	.-66     	; 0x7fb0 <BootloaderAPI_UNUSED2>
	rjmp BootloaderAPI_UNUSED3 ; UNUSED ENTRY 3
    7ff2:	df cf       	rjmp	.-66     	; 0x7fb2 <BootloaderAPI_UNUSED3>
	rjmp BootloaderAPI_UNUSED4 ; UNUSED ENTRY 4
    7ff4:	df cf       	rjmp	.-66     	; 0x7fb4 <BootloaderAPI_UNUSED4>
	rjmp BootloaderAPI_UNUSED5 ; UNUSED ENTRY 5
    7ff6:	df cf       	rjmp	.-66     	; 0x7fb6 <BootloaderAPI_UNUSED5>

Disassembly of section .apitable_signatures:

00007ff8 <BootloaderAPI_Signatures>:
    7ff8:	00 70       	andi	r16, 0x00	; 0
    7ffa:	00 00       	nop
    7ffc:	10 df       	rcall	.-480    	; 0x7e1e <__data_load_start+0x56>
    7ffe:	fb dc       	rcall	.-1546   	; 0x79f6 <Endpoint_ConfigureEndpoint_Prv+0x1e>
